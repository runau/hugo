[{"content":"lambdaで変数やステータスを保持しておきたい時、各サービス間のやり取りでパラメータを共有したい時。\n別に何でもいいんだけど、何が一番いいのか？考えてみます。\nなんでこんなこと言いだしたのかというと、先月たいして使ってないはずのSSMが0.02USDもかかったからですww\nはじめに 今どうしているかというと、すごいふんわりだけど\n  一つだけの変数っぽいのはSSM\n  すごい長くなる時はS3\n  キーごとに必要な時はdynamoDB\n  一回きりで使い捨ての時はSQS\n  って使っている。\nでも、よく考えたら、極論、全部どれかでも行けそうな気もするww\nなので、料金、安定性、制限、速さの4つの観点で比較したいんだけど…、とりあえずその料金編！\nちょうど今、こいつのステータス管理をどうしようか悩んでいて…\nこれは料金さえ安ければ、他は犠牲にしてもいいのだwww\n検証 料金比較 ※2020/03/07時点　東京リージョン\nSSM 公式の料金ページ\n⇒get:0.05USD/1万　put:0.05USD/1万\nS3 公式の料金ページ\n⇒get:0.0037USD/1万　put:0.047USD/1万\ndynamoDB(オンデマンド) 公式の料金ページ\n⇒get:0.00285USD/1万　put:0.014269USD/1万\nSQS 公式の料金ページ\n⇒get:0.0040USD/1万　put:0.0040USD/1万\nSQSだけよく分からないんだよな…。これであってるのか？\n料金まとめ こうやって単純に比較すると、\ndynamoDB＜s3＜SQS＜SSM\nってとこですね。\nSSM高くね？\nという事で、この抽選botでは、試しにdynamoDBをSSM風に使って行ってみたいと思います。\nおまけ dynamoDB(プロビジョニング)\n公式の料金ページ\nこれなら25ユニットまでに抑えれば、どんなに使っても無料ですからね。\nプロビジョニングのdynamoDB最強説かもしれないww\nでも私は、プロビジョニングは25ユニット使い切ってしまっているので、使えません…。\n","description":"","id":0,"section":"posts","tags":["Python","aws","SES","SQS","SNS","lambda","SSM","dynamoDB"],"title":"ちょっとデータを残したい時 SSM,S3,dynamoDB,SQSどれがいいのか？検証","uri":"https://encr.jp/blog/posts/20200307_lunch/"},{"content":"昨日作った抽選botの解説とコード公開します！\n最新のコードはこちら\n抽選botの詳細はこちら\n仕組み 前回のbotの進化系です。\n以下の動作を10分置きに繰り返します。\n抽選botの抽選ツイートを取得 既にリプライ済のツイートに再度リプライしないように、まず、自分のしたツイートを取得する。\n安定稼働してきたら、このプログラムの履歴を信じて、あえて毎回twitterから取得しなくてもいいんだけど、今は信用ならないので、毎回取得しなおす。\n1 2 3 4 5 6 7 8 9 10  # botのツイートを取得 # botのツイートを取得 doneList = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name={SCREEN_NAME}\u0026amp;count=10\u0026#39;, auth=getOauth() ).json() if \u0026#34;errors\u0026#34; in doneList: print(doneList) return doneList = list(map(lambda x: x[\u0026#34;in_reply_to_status_id_str\u0026#34;], doneList))   募集ツイートを取得 まず募集ツイート。つまり、指定のタグ「#抽選bot」付きのtweetを取得します。\n指定のタグ「#抽選bot」付きのtweetを取得 1 2 3 4 5 6  # 指定タグのツイートを取得 search = \u0026#39;%23抽選bot\u0026#39; response = requests.get( f\u0026#39;https://api.twitter.com/1.1/search/tweets.json?q={search}\u0026amp;count=50\u0026amp;lang=ja\u0026amp;result_type=mixed\u0026amp;tweet_mode=extended\u0026#39;, auth=getOauth() ).json()   こんな感じ。\nリツイート、リプライを排除 上で取得した中からリツイート、リプライを排除します。\n1 2 3 4 5 6  if \u0026#34;retweeted_status\u0026#34; in status: print(\u0026#34;RT skip\u0026#34;) continue if status[\u0026#34;in_reply_to_status_id_str\u0026#34;]: print(\u0026#34;rep skip\u0026#34;) continue   確立を取得 ツイートのテキストから確率を取得\n1 2 3  lot_pro = re.findall(r\u0026#39;(\\[.+?\\]\\(\\d+)\u0026#39;, main_text) lot_pro = list(map(lambda x: {\u0026#34;name\u0026#34;: re.findall( r\u0026#39;\\[(.+)\\]\u0026#39;, x)[0], \u0026#34;pro\u0026#34;: int(re.findall(r\u0026#39;(\\d+)\u0026#39;, x)[0])}, lot_pro))   ↑正規表現で、[]()の中身を取得して、形を変換\n↓取得した確率を確認のためにめっセージに展開しなおす。\n1 2 3 4  lot_message = \u0026#34;\u0026#34; for p in lot_pro: lot_message += f\u0026#39;{p[\u0026#34;name\u0026#34;]}:{p[\u0026#34;pro\u0026#34;]}%,\u0026#39; data[\u0026#34;lot_message\u0026#34;] = lot_message   募集ツイートにリプライ まず、メッセージを作成する。\n確率が取得できていれば、その確認メッセージ。\n確率が取得できなければ、エラーメッセージ。\n1 2 3 4 5 6 7 8  if \u0026#34;lot_pro\u0026#34; not in data: if len(lot_pro) == 0: message = f\u0026#39;#抽選bot のご利用ありがとうございます！\\n申し訳ありませんが、確立を読み取れませんでした。\\n正しい使い方などは↓のリンクをご覧ください。\\nhttps://encr.jp/blog/posts/20200306_morning/\\n\\n※このツイートはbotからの自動送信です\u0026#39; else: data[\u0026#34;lot_pro\u0026#34;] = lot_pro data[\u0026#34;lot_message\u0026#34;] = lot_message message = f\u0026#39;#抽選bot のご利用ありがとうございます！\\n{lot_message[:-1]}で抽選いたします。\\nhttps://encr.jp/blog/posts/20200306_morning/\\n\\n※このツイートはbotからの自動送信です\u0026#39; data[\u0026#34;main_reply_message\u0026#34;] = message   それをリプライ。\n1 2 3 4 5 6 7 8  # リプライする in_reply_to_status_id = tweet_id replyResponse = requests.post( f\u0026#39;https://api.twitter.com/1.1/statuses/update.json\u0026#39;, data={\u0026#34;status\u0026#34;: message, \u0026#34;in_reply_to_status_id\u0026#34;: int(in_reply_to_status_id), \u0026#34;auto_populate_reply_metadata\u0026#34;: True}, auth=getOauth() ).json()   応募ツイートを取得 募集ツイートをした人宛のリプライを取得 募集ツイートをした人宛のリプライを全て取得\n1 2 3 4 5 6  # 指定タグのツイート者宛のリプライを取得 search = f\u0026#34;%40{status[\u0026#39;user\u0026#39;][\u0026#39;screen_name\u0026#39;]}\u0026#34; repResponse = requests.get( f\u0026#39;https://api.twitter.com/1.1/search/tweets.json?q={search}\u0026amp;count=10\u0026amp;lang=ja\u0026amp;result_type=mixed\u0026#39;, auth=getOauth() ).json()   必要な応募ツイートのみに絞り込む リツイートを排除\n1 2 3  if \u0026#34;retweeted_status\u0026#34; in status: print(\u0026#34;RT skip\u0026#34;) continue   募集ツイートへのリプライ以外を排除\n1 2  if rep_status[\u0026#39;in_reply_to_status_id_str\u0026#39;] != tweet_id: continue   抽選botのリプライを排除。リプライ済の応募ツイートを排除\n1 2 3  if rep_status[\u0026#39;id_str\u0026#39;] in doneList or rep_status[\u0026#39;user\u0026#39;][\u0026#39;screen_name\u0026#39;] == SCREEN_NAME: print(f\u0026#34;{rep_status[\u0026#39;user\u0026#39;][\u0026#39;name\u0026#39;]} reply done\u0026#34;) continue   抽選してリプライ 抽選する ちょっと雑ですが…。\n0～100までの乱数を作って、確率を一つずつ足して、hitしたら当選。\n最後までhitしなかったら落選。\n1 2 3 4 5 6 7 8 9  # 抽選する sump = 0 yourp = random.random() * 100 lot = None for p in lot_pro: sump += p[\u0026#34;pro\u0026#34;] if yourp \u0026lt;= sump: lot = p[\u0026#34;name\u0026#34;] break   メッセージ作成 1 2 3 4  if lot is not None: message = f\u0026#39;{rep_status[\u0026#34;user\u0026#34;][\u0026#34;name\u0026#34;]}さん、リプありがとうございます！\\n「{lot}」が当選しました。\\n\\n※このツイートはbotからの自動送信です #抽選bot\u0026#39; else: message = f\u0026#39;{rep_status[\u0026#34;user\u0026#34;][\u0026#34;name\u0026#34;]}さん、リプありがとうございます！\\n残念ながら、今回は落選してしまいました…\\n\\n※このツイートはbotからの自動送信です #抽選bot\u0026#39;   リプライ 1 2 3 4 5 6  replyResponse = requests.post( f\u0026#39;https://api.twitter.com/1.1/statuses/update.json\u0026#39;, data={\u0026#34;status\u0026#34;: message, \u0026#34;in_reply_to_status_id\u0026#34;: in_reply_to_status_id, \u0026#34;auto_populate_reply_metadata\u0026#34;: True}, auth=getOauth() ).json()   独り言 うーん、思ったより、大変だったww\n最新のコード全文はこちらです。\n抽選botの詳細はこちら\nフォロワー6000人企画が楽しみですww\nハッシュタグ付けて頂ければ誰でも使えるので、皆さんもぜひ使ってやってください！\n","description":"","id":1,"section":"posts","tags":["hugo","Python","twitter","twitter_api","aws","lambda"],"title":"抽選botの作り方","uri":"https://encr.jp/blog/posts/20200307_morning/"},{"content":"抽選bot作りました！誰でも使えます。\n使い方   企画者が募集ツイートをする。\n  参加者が募集ツイートに対してリプライする。\n  botが募集内容に応じた抽選を行い、参加者のリプライに対してリプライします！\n  サンプル おみくじサンプル 募集ツイート おみくじします！ #抽選bot\n[大吉](10%)\n[中吉](50%)\n[小吉](40%)\n参加ツイート 参加しますー！\nbotツイート リプありがとうございます。\n「大吉」が当選しました！\nリプありがとうございます。\n「中吉」が当選しました！\n企画サンプル 募集ツイート フォロワー様6000人ありがとうございます！\n企画します！\n抽選で5名様を私のtwitterで紹介します！ #抽選bot\n[twitterでご紹介](1%,5)\n〆3/8 24:00\n※締め切り日の指定はまだ未実装です！\n参加ツイート 参加しますー！\nbotツイート リプありがとうございます。\n「twitterでご紹介」が当選しました！\nリプありがとうございます。\n残念ながら、今回は落選してしまいました…\n使い方の詳細条件 募集側の条件   #抽選bot のハッシュタグを入れること\n  鍵垢でないこと\n  リツイートでなく、メンションも入っていないこと\n  下記のように条件を指定していること\n  上限数が決まっている場合は、\n[twitterでご紹介](1%,5)\nのように、\n決まっていない場合は、\n[大吉](10%)\nのように、条件を指定してください。\n※上限数制限はまだ未実装です…。\nフォロワー様6000人になるまでに作る！\n参加側の条件   鍵垢でないこと\n  募集ツイートへの直接のリプライであること\n  募集者地震でないこと\n募集者は自分のツイートにリプライしても参加扱いにはなりません。\n  検討中機能 そのうち機能追加します。\n  RT,引用RTを参加対象にする\n  締め切り日の指定\n  コードの公開＆解説 全コードはこちら\n抽選botの解説はこちら\n","description":"","id":2,"section":"posts","tags":["Python","twitter","aws","lambda"],"title":"抽選bot利用方法","uri":"https://encr.jp/blog/posts/20200306_morning/"},{"content":"ついに抽選bot用のアカウントを作ることにしました！\ntwitterアカウントはこちら\ntwitterアカウント作成 これは説明不要ですよね？\n普通にアカウントを作成します。\nAPIの申請 基本設定 こちらからapiの申請ができます。\ntwitter apiはこの申請が通らない限り使うことはできません。\nログインして、appsをクリックします。\ncreate an app をクリックすると、メッセージが出ます。applyでOKです。\nすると、こんな画面が出ます。この画面がgoogle翻訳出来ないからつらい…。\nこの黄色の部分をまず見て頂き、商用利用(professional)なのか、私用利用(hobbyist)なのか…ryを選びます！\nhobbyistのMaking a botを選んでみます。\n住みと名前を入れます。\n内容入力 で、ここからが大変な作業です。\ntwitter apiを使うのが大変と言われる所以です…。\n枠の下に「Response must be at least 200 characters」と書いてあるのですが、つまり、最低200文字は書いてねというものです。\nしかも、英語で…。\n↓みたいにgoogle翻訳に助けてもらいますww\n一応、私の申請した内容も載せておきますね。\nこんなんでも通るよって言うサンプルと思っていただければと思います。\n「#抽選bot」というタグを付けたツイートに自動でリプライします。\n元のツイートに抽選の対象者、抽選の景品、当選率などの設定を記載頂きます。それを読み取り、その設定に基づき、抽選を行い、結果をリプライします。\n↑は全員必須なのですが、それ以降は、必要な箇所のみの記入になります。\n私はリプライをしたいので、use Retweetがあるをyesにして、その内容を書きます。\n「#抽選bot」というタグを付けたツイートに自動でリプライします。\n設定の記載に不備がある場合は、その指摘と、正しい書き方を指導するリプライを送ります。\n抽選対象者に対して、抽選結果のリプライを送ります。\nをgoogle翻訳したものを貼り付けました。\n英語としてはダメかもしれませんが、こんな感じでも意味が伝われば受かりますww\n↓確認画面です。\n↓メールを設定せずに進めていくと、途中でこのようなエラーが出ます。\n Server error - application not submitted\nUser must have verified email on file prior to submitting application\n twitterを開いて、設定からメールアドレスを登録してください。\nで、メールアドレス登録後、そのまま進めていくと、このような画面になります。\nYou did it！！\n申請作業はこれでおしまいです。\n↓のようなメールが届くので、urlを押して、メールの認証をします。\nこの画面が出たら、本当にぜんぶおしまい！\nあとは、承認されるのを待つだけです。\nうーん、長かったw\n早ければ明日返事がきます！\n","description":"","id":3,"section":"posts","tags":["twitter"],"title":"twitter api申請をする 例文有","uri":"https://encr.jp/blog/posts/20200305_lunch/"},{"content":"とてもありがたいことに、最近、このブログの真似をして、hugoブログを作っているって方が出てきて下さったので、作り方や、カスタマイズの方法をまとめたいと思います。\nhugoブログとは？ DBがいらない。アプリケーションサーバーがいらない静的なブログです。\n静的サイトジェネレーターと呼ばれる、静的サイトを作るスクリプトで作ります。\n(go言語で書かれたスクリプトです。)\nこのような仕組みで動いています。\n私は、このような構成で作っています。\n静的？サーバー？って方は↓の記事を読んでいただければと思います//\nhugoブログのサーバーの仕組み　なぜ60円でブログが作れるのか？\nビルド ↑の記事でも触れましたが、hugoブログは出来上がったページをファイルサーバーに置いておき、それをそのまま表示します。\nWordpressやECサイトなどでは、アプリケーションサーバーと呼ばれるサーバーがhtmlを生成し、それを表示するのですが、hugoはそれを事前に「ビルド」して、作成しておきます。\nこんな感じ。\n各記事はmd(マークダウン)という形式で書きます。\nビルドをかけると、↑のように、各記事のmdとベースのhtmlから、記事のhtmlが作成されます。\nで、このベースhtml、ベースcssと言っているものがテーマと呼ばれるもので、いろんなデザインの物が公開されており、好きなものを選ぶことができます。\nhugo公式サイトのデザイン集\nもちろん、自分で作ることもできます//\nhugoブログの始め方 私がこのブログを立ち上げたときの記事がこちらです。\nインストールで困ったときは公式のクイックスタートをご覧いただくのがいいと思います。\nhugoの設定やトラブルシューティング記事まとめ 設定関連 hugo初期設定と戦ってみる\n 記事出てこない問題 cssとか反映されない問題 タイトルを変える  hugo/zzoのカスタムヘッダーを設定\nhugo/zzoのタイトルとプロフィールを変更\nhugo/zzoに独自のfaviconを設定\nhugoのテーマをzzoに変えてみる\nadsense関連 adsenseがヘッダーに表示されないバグ修正\npc版ブログにadsense広告を追加する！\nhugo/zzoブログでadsense審査通ったw\nその他 スライドシェアをブログに埋め込む\ntwitterカード画像自動生成機能\nhugo関連記事の前一覧 hugo関連記事の一覧はこちら\nこのブログはまだコメント機能がないので、何かご不明点とうありましたら、ぜひこちら質問箱からご質問頂ければ、ブログで回答いたします_(._.)_\nコメント機能も作らないとな…\n","description":"","id":4,"section":"posts","tags":["hugo"],"title":"hugoブログの作り方","uri":"https://encr.jp/blog/posts/20200305_morning/"},{"content":"lambdaでdynamoDBを更新することってよくあるんですが、キーが違ったりすると、毎回コード書着かえたりしないといけなくて…。\nめんどくさいので、汎用的に使えるのを作りました。\ndyanmoDBからまず定義を取ってきて、その定義に沿ってデータ取得、更新をします。\n前提 私は全dynamoDBを\n{ パーティションキー:パーティションキー ,\u0026quot;data\u0026quot;:data } か\n{ パーティションキー:パーティションキー ,ソートキー:ソートキー ,\u0026quot;data\u0026quot;:data } って形で持ってます。\nなので、更新を掛けたい時は、dataの中の項目を更新したい事がほとんどです。\n対応ケース beforeデータ\n1 2 3 4 5 6 7  { \u0026#34;userId\u0026#34;:\u0026#34;00001\u0026#34; ,\u0026#34;data\u0026#34;:{ \u0026#34;name\u0026#34;:\u0026#34;runa\u0026#34; ,\u0026#34;age\u0026#34;:\u0026#34;26\u0026#34; } }   投入データ\n1 2 3 4 5 6 7  { \u0026#34;userId\u0026#34;:\u0026#34;00001\u0026#34; ,\u0026#34;data\u0026#34;:{ \u0026#34;age\u0026#34;:\u0026#34;27\u0026#34; ,\u0026#34;tel\u0026#34;:\u0026#34;08012345678\u0026#34; } }   afterデータ\n1 2 3 4 5 6 7 8  { \u0026#34;userId\u0026#34;:\u0026#34;00001\u0026#34; ,\u0026#34;data\u0026#34;:{ \u0026#34;name\u0026#34;:\u0026#34;runa\u0026#34; ,\u0026#34;age\u0026#34;:\u0026#34;27\u0026#34; ,\u0026#34;tel\u0026#34;:\u0026#34;08012345678\u0026#34; } }   こうしたい。\nで、↑はkeyがuserIdだけど、sortKeyがあった時も、おんなじ感じで良きに計らってほしいw\nコード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  import json import boto3 from boto3.dynamodb.conditions import Key import sys def editData(tableName,setValue): dynamoDB = boto3.resource(\u0026#34;dynamodb\u0026#34;) table = dynamoDB.Table(tableName) #dynamoの定義を取得 client = boto3.client(\u0026#39;dynamodb\u0026#39;) response = client.describe_table( TableName=tableName ) keys = dict(map(lambda x:(x[\u0026#34;KeyType\u0026#34;],x[\u0026#34;AttributeName\u0026#34;]),response[\u0026#34;Table\u0026#34;][\u0026#34;KeySchema\u0026#34;])) print(keys) #sortキーの有無を確認しながら、今の値を取得 if len(response[\u0026#34;Table\u0026#34;][\u0026#34;KeySchema\u0026#34;]) == 2: data = table.get_item(Key={keys[\u0026#34;HASH\u0026#34;]:setValue[keys[\u0026#34;HASH\u0026#34;]],keys[\u0026#34;RANGE\u0026#34;]:setValue[keys[\u0026#34;RANGE\u0026#34;]]}) else: data = table.get_item(Key={keys[\u0026#34;HASH\u0026#34;]:setValue[keys[\u0026#34;HASH\u0026#34;]]}) if \u0026#34;Item\u0026#34; in data: item = data[\u0026#34;Item\u0026#34;] print(f\u0026#34;before:{item}\u0026#34;) else: print(\u0026#34;err\u0026#34;) return #更新項目の設定。 #私の場合は、data内の項目を一つずつ更新してます。 #適宜変更ください。 if \u0026#34;data\u0026#34; in setValue: for k in setValue[\u0026#34;data\u0026#34;].keys(): item[\u0026#34;data\u0026#34;][k] = setValue[\u0026#34;data\u0026#34;][k] print(f\u0026#34;after:{item}\u0026#34;) table.put_item(Item=item) def main(param): editData(param[\u0026#34;tableName\u0026#34;],param[\u0026#34;setValue\u0026#34;]) def lambda_handler(event, context): try: print(json.dumps(event)) if \u0026#34;body\u0026#34; in event: print(event[\u0026#34;body\u0026#34;]) return main(json.loads(event[\u0026#34;body\u0026#34;])) elif \u0026#34;body-json\u0026#34; in event: print(event[\u0026#34;body-json\u0026#34;]) return main(event[\u0026#34;body-json\u0026#34;]) else: return main(event) except: import traceback traceback.print_exc()   lambda_handlerの中は、通常のapi-gatewayからでも、CORSのapi-gatewayからでも、lambdaの直の呼び出しでも対応できるようにしてます。\n使うときは、必要な部分だけ使っていただければと思います//\n","description":"","id":5,"section":"posts","tags":["Python","aws","lambda","dynamoDB"],"title":"dynamoDBを更新するlambdaを作成","uri":"https://encr.jp/blog/posts/20200304_lunch/"},{"content":"質問箱を始めました。\nで、質問箱はこちらですよっていうのをtwitterのプロフィールに載せたかったんですが、メインのurlはブログに設定したかったので、プロフィールに記載する事に…。\nそうしたら、urlが長くて、プロフィールの貴重な文字数をがんがん奪っていきやがったので、短縮url作ることにしました。\nbefore\nafter\ntwitterに学ぶ 短縮urlと言えばtwitter。なので、自分のツイートからurlを取ってきて、その中身を覗いてみることにしました。\nこんな感じで見たいurlの頭にview-source:ってつけると、そのurlのリンクが見れます。\nview-source:https://t.co/sUh1TXnwn7?amp=1\nで中身を確認すると、こんな感じ\n1  \u0026lt;head\u0026gt;\u0026lt;noscript\u0026gt;\u0026lt;META http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;0;URL=https://peing.net/ja/engineergirl_w?event=0\u0026#34;\u0026gt;\u0026lt;/noscript\u0026gt;\u0026lt;title\u0026gt;https://peing.net/ja/engineergirl_w?event=0\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\u0026lt;script\u0026gt;window.opener = null; location.replace(\u0026#34;https:\\/\\/peing.net\\/ja\\/engineergirl_w?event=0\u0026#34;)\u0026lt;/script\u0026gt;   うん、実にシンプル。\n転送してるだけですね。\nなので、これをそのままコピーして、自分のドメインの短めの位置に置きます。\n1 2 3 4 5  \u0026lt;head\u0026gt;\u0026lt;noscript\u0026gt; \u0026lt;META http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;0;URL=https://peing.net/ja/engineergirl_w?event=0\u0026#34;\u0026gt;\u0026lt;/noscript\u0026gt; \u0026lt;title\u0026gt;https://peing.net/ja/engineergirl_w?event=0\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;script\u0026gt;window.opener = null; location.replace(\u0026#34;https:\\/\\/peing.net\\/ja\\/engineergirl_w?event=0\u0026#34;)\u0026lt;/script\u0026gt;   index.htmlは省略できるので、encr.jp/qでアクセスできるようになりました！\nこれでプロフィールも長めに入れられる！\n使いたい方は、↑の二か所のurlを自分の転送したいリンクに置き換えてご利用下さい！\n短いですが、以上。\n","description":"","id":6,"section":"posts","tags":["質問箱"],"title":"質問箱のurlが長いので、短縮urlを自作してみた","uri":"https://encr.jp/blog/posts/20200304_morning/"},{"content":"自動予約受付アプリの中で、メールの転送作業が必要で、その転送設定をユーザーに勝手にしてもらいたいので、lambdaで実装する必要があった。\nSNSのtopicを新規で作って、そこにsubscriptionを設定する。\nimport boto3 def main(param): client = boto3.client('sns') response = client.create_topic( Name=f'sendMail{param[\u0026quot;shopId\u0026quot;]}' ) print(response) arn = response[\u0026quot;TopicArn\u0026quot;] sns = boto3.resource('sns') topic = sns.Topic(arn) subscription = topic.subscribe( Protocol='email', Endpoint=param[\u0026quot;mail\u0026quot;], ReturnSubscriptionArn=True ) def lambda_handler(event, context): try: print(event) print(event[\u0026quot;body\u0026quot;]) return main(json.loads(event[\u0026quot;body\u0026quot;])) except: import traceback traceback.print_exc() できた。\neventはapi gatewayからも叩けるように、bodyの中にdumpsしてあるjsonが入っている想定。\n{body:\u0026quot;{\\\u0026quot;shopId\\\u0026quot;:\\\u0026quot;xxx\\\u0026quot;,\\\u0026quot;mail\\\u0026quot;:\\\u0026quot;xxx\\\u0026quot;}} もちろん、メールアドレスの認証は必要なので、awsからの認証メールのリンクをクリックして、認証を完了させる必要があります。\n","description":"","id":7,"section":"posts","tags":["Python","aws","SNS","lambda"],"title":"boto3でSNSにtopicとsubscriptionを作ってみた","uri":"https://encr.jp/blog/posts/20200303_lunch/"},{"content":"liffのバージョンをそろそろ上げないとかなと思って、v2.0にあげてみたら、liff.initにliffIdが必須でした…。\nでも、私は一つのhtmlを複数liffで使いまわししており、liffIdの設定がhtml側ではできません…。\nURLから取得できないか？ clientCd(liffIdの数字部分)だけは取得できたのですが、liffIdの取得は出来ませんでした…\nURLのパラメータで渡す 結局これしか思いつかず、URLにliff_idというパラメーターを追加して呼び出すことにしました…。\njsのコードはこんな感じ\n1 2 3 4 5 6 7 8 9 10 11 12  function getParam(name, url) { if (!url) url = window.location.href; name = name.replace(/[\\[\\]]/g, \u0026#34;\\\\$\u0026amp;\u0026#34;); var regex = new RegExp(\u0026#34;[?\u0026amp;]\u0026#34; + name + \u0026#34;(=([^\u0026amp;#]*)|\u0026amp;|#|$)\u0026#34;), results = regex.exec(url); if (!results) return null; if (!results[2]) return \u0026#39;\u0026#39;; return decodeURIComponent(results[2].replace(/\\+/g, \u0026#34; \u0026#34;)); } liff.init({ liffId: getParam(\u0026#39;liff_id\u0026#39;) })   なにがベストプラクティスなんだろう…\n短いけど、朝活おしまい！\n","description":"","id":8,"section":"posts","tags":["Python","aws","s3"],"title":"liffのバージョンをv2.0に上げたら、liffIdが必要になって困った話","uri":"https://encr.jp/blog/posts/20200302_morning/"},{"content":"やーっとリリースできました！\n結局全部作り切れずに、一部機能先送りにしてしまいました…。\nいやぁ、一日作業してたはずなのに、遅くなった…。\nサイトはこちら\n自動予約受付ができるlinebotです。\nしかも、あんまりテストできてないから、まだバグだらけかも…。\n明日からしっかりテストしよう…。\nあ、ちゃんとリリース出来たら、アフィリエイターさんも募集します！\n一成約一万円くらい謝礼お支払いします。\nしばしお待ちくださいませ。\n宣伝w これはBtoBの有料サービスなので、BtoCの無料サービスがよかったら、生理予測アプリで遊んでみてくださいww\nこっちはもうテストも済んでるし、2カ月くらいバグもでてないからもう安心w\n女性向けではあるのですが、linebotってこんなものって知ってもらうために遊んでもらう分には大歓迎です！\n構成とか、作ることになった流れなんかは、こちらのLT資料を見て頂ければと思います！\nふぅ。今日はブラック企業並みに働いてしまったので、こんなもんでおしまいw\nまた明日からブログ中心に頑張りますー！\nおやすみなさい…\n","description":"","id":9,"section":"posts","tags":["Python","aws","GCP","google_calendar","SES","SQS","SNS","lambda"],"title":"ついに！アプリリリース！治療院向け自動予約アプリ","uri":"https://encr.jp/blog/posts/20200301_morning/"},{"content":"今日は…、forkwellの経歴とかを書きますww\nずっとめんどくさくて書いてなくて、やっぱりこれ書かないとスカウトとかあんまり来ないよなーと思ったw\nforkwellとは？ こちら の求人サイト。\n登録で2000円のアマゾンギフト券もらえたりします。\nポートフォリオの登録が出来て、そのポートフォリオをみた企業がスカウトを送ってきてくれるという素敵なサイトです。\nアマゾンギフト券欲しい方は、登録の上、この招待コードを入れてくれればww\n招待コード「GJJNYT」\nあとね、スカウトメールを受けて、面接とか見学とかで会社に行くと、一回1000円もらえる！\n今度、スカウトくれた会社めぐりしようかなーと企み中ww\nちなみに、私のポートフォリオはこちら\nhugoブログをforkwellに連携した話はこちら\n経歴の書き方 ちなみに今はこちら\nとりあえず何かしら書かないと登録できなかったから、会社名と、選択式のものを選択しただけの状態…。\nで、気になった企業さんが、これをもっと書いてほしいよっていうリクエストを私たちに送れるんだけど、それがたくさん届いている状態ww\nはい、ちゃんと書きます！\nあと、この情報は、こんな感じで公開範囲を選べる。\n今は会社名を書いてしまっているから、公開出来ないので、ついでに公開できるレベルの名称に書き換える！\n予測とか出てくるから、おそらくforkwellの意図した形ではないけれども、全体公開にしたいので、こんな感じにしてみましたw\nで、詳細はマークダウンで書けます！\nという事は、画像入れたり、リンク張ったり何でもできる！！最高//\nテンプレートって押すと、こんな感じのが勝手に出てくれます。\nちょっと修正すればOK\n後は現場ごとの内容をいつも営業に使ってるスキルシートからコピペをする作業ww\n………。\n完成 できた…。\nもし、どんなレベルで書いたらいいのか悩んだら、私のポートフォリオも参考にしてみてください//\nスカウト来るかなー？？\n色々話聞きに行って見るのも楽しそうだよね！わくわく//\n話聞きに行くだけでも1000円もらえるしねww\nおしまい。\n","description":"","id":10,"section":"posts","tags":["forkwell"],"title":"forkwellで経歴書公開","uri":"https://encr.jp/blog/posts/20200229_lunch/"},{"content":"昨日の問題解決編\nhtmlメールをちゃんと読み替える。\n今は、なんかこんな感じになっている…\nテスト本文 -- ○●-------------------------------------------------------------------------●○ エンジョイクリエイト URL: https://encr.jp line公式アカウントで生理予定日簡単予測 https://encr.jp/blue ○●-------------------------------------------------------------------------●○ \u0026lt;div dir=\u0026quot;auto\u0026quot;\u0026gt;テスト本文\u0026lt;/div\u0026gt;-- \u0026lt;br\u0026gt;\u0026lt;div dir=\u0026quot;ltr\u0026quot; class=\u0026quot;gmail_signature\u0026quot; data-smartmail=\u0026quot;gmail_signature\u0026quot;\u0026gt;○●-------------------------------------------------------------------------●○\u0026lt;br\u0026gt;　エンジョイクリエイト\u0026lt;br\u0026gt;　URL: \u0026lt;a href=\u0026quot;https://encr.jp\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;https://encr.jp\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt;　line公式アカウントで生理予定日簡単予測\u0026lt;br\u0026gt;　\u0026lt;a href=\u0026quot;https://encr.jp/blue\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;https://encr.jp/blue\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;○●-------------------------------------------------------------------------●○\u0026lt;/div\u0026gt; なんか、textもhtmlも来てて、両方来るのが邪魔って感じなのかな…。\nメールの仕組みを調べる\nすごい分かりやすいサイト見つけた\nこちらによると、Content-Typeヘッダの値「text/plain」だとtext、「text/html」だとhtmlになるらしい。\nで、html対応しているサーバーはhtmlを表示して、対応していないサーバーはplainを表示するみたい！\nよくできてるねーww\nだから、とりあえず、「text/plain」だけ拾うようにしてみる。\n1 2 3 4 5 6 7 8 9 10 11  if not attach_fname: charset = str(part.get_content_charset()) if charset: body = part.get_payload(decode=True).decode(charset, errors=\u0026#34;replace\u0026#34;) else: body = part.get_payload(decode=True) if part.get_content_type() == \u0026#34;text/html\u0026#34;: body_html += body elif part.get_content_type() == \u0026#34;text/plain\u0026#34;: body_text += body   こんな感じ。\nで、body_textだけを転送するようにして、受信すると、\nテスト本文 -- ○●-------------------------------------------------------------------------●○ エンジョイクリエイト URL: https://encr.jp line公式アカウントで生理予定日簡単予測 https://encr.jp/blue ○●-------------------------------------------------------------------------●○ うん。いい感じ。\n今日の朝活おしまい！\n","description":"","id":11,"section":"posts","tags":["Python","aws","SES","SQS","SNS","lambda"],"title":"htmlメールを何とかする","uri":"https://encr.jp/blog/posts/20200229_morning/"},{"content":"このブログはレンタルサーバーを借りていないので、メールサーバーもありません。\nSESでメールを受信し、lambdaで本文を抽出して、gmailに転送していますw\nですが、とりあえずで作ったlambdaなので、色々問題が…。\nそれぞれ解決していきたいと思います！\n現状確認 こんな感じで動いています。\n前に記事も書いてるので、コードとか詳しくはこちら\n 問題①　送信アドレス、受信アドレス、タイトルが分からない  本文を抽出しているだけなので、本文以外の情報が分かりません。\n大問題ww\n 問題②　htmlメールが汚い  htmlメールがすごく読みずらいので、なんとかいい方法を考えたいと思います。\n解決編はこちら\n 問題③　問題というか改善というか、読む必要のないメールは情報だけ欲しい  例えば、毎月の月報だとか、銀行の振込履歴だとか…。\n別に読む必要ないから、いい感じにdynamoかなんかに格納して、終わっておいてほしい\n 問題④　ポイント付きメールを勝手に押してほしいww  ポイントタウンってポイントサイトやってるんですけどね？\nポイント付きのメールが来るんですよw\nあれ、勝手にポイントもらっておいてほしいww\n究極の改善というか、チートというかwww\n問題①を解決 まずは、ここから対応していきます。\n送信アドレス、受信アドレス、タイトルが分からない…。\nlambdaがね、受信はしているんですよ。\nなので、それを認識してあげるだけ！\nSQSからのメッセージを確認 lambdaのeventにはこんな感じのデータが送られてくる。\n{ \u0026quot;Records\u0026quot;: [ { \u0026quot;messageId\u0026quot;: \u0026quot;2a13ef0e-bc7f-41e5-b711-25689de7f5eb\u0026quot;, \u0026quot;receiptHandle\u0026quot;: \u0026quot;AQEBaH9NxRsK5YT～略～\u0026quot;, \u0026quot;body\u0026quot;: \u0026quot;{\\\u0026quot;notificationType\\\u0026quot;:\\\u0026quot;Received\\\u0026quot;,\\\u0026quot;mail\\\u0026quot;:～略～}\u0026quot;, \u0026quot;attributes\u0026quot;: { \u0026quot;ApproximateReceiveCount\u0026quot;: \u0026quot;1\u0026quot;, \u0026quot;SentTimestamp\u0026quot;: \u0026quot;1582892255806\u0026quot;, \u0026quot;SenderId\u0026quot;: \u0026quot;AIDAIYLAVTDLUXBIEIX46\u0026quot;, \u0026quot;ApproximateFirstReceiveTimestamp\u0026quot;: \u0026quot;1582892255874\u0026quot; }, \u0026quot;messageAttributes\u0026quot;: {}, \u0026quot;md5OfBody\u0026quot;: \u0026quot;0c43f48330cfb83fcb461e64745xxxxx\u0026quot;, \u0026quot;eventSource\u0026quot;: \u0026quot;aws:sqs\u0026quot;, \u0026quot;eventSourceARN\u0026quot;: \u0026quot;arn:aws:sqs:ap-northeast-1:908725900000:receive-mail-rn\u0026quot;, \u0026quot;awsRegion\u0026quot;: \u0026quot;ap-northeast-1\u0026quot; } ] } メールの中身はこのbodyのなか。\n展開するとこんな感じ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99  { \u0026#34;notificationType\u0026#34;: \u0026#34;Received\u0026#34;, \u0026#34;mail\u0026#34;: { \u0026#34;timestamp\u0026#34;: \u0026#34;2020-02-28T12:17:35.003Z\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;FKTPxJDawxxxxxp@post2.pointtown.com\u0026#34;, \u0026#34;messageId\u0026#34;: \u0026#34;pcbg7k43or9pkbelps3mpb801blqf8xxxxxxxxxx\u0026#34;, \u0026#34;destination\u0026#34;: [ \u0026#34;pointxxxx@xxxx.jp\u0026#34; ], \u0026#34;headersTruncated\u0026#34;: false, \u0026#34;headers\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Return-Path\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;\u0026lt;FKTPxJDawsxxxxx@post2.pointtown.com\u0026gt;\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Received\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;from relay.gmo-media.jp ～略～\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;X-SES-Spam-Verdict\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;FAIL\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;X-SES-Virus-Verdict\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;PASS\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Received-SPF\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;pass ～略～;\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Authentication-Results\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;amazonses.com; spf=pass ～略～;\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;X-SES-RECEIPT\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;AEFBQUFBQUFBQUFHbWcrMVRDdG9ueWd2VFJlTDNGZEZjVW5LNCt～略～\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;X-SES-DKIM-SIGNATURE\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;a=rsa-sha256; q=dns/txt; b=PykRrgWXF/～略～;\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Received\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;(qmail 8117 invoked by uid 60057); 28 Feb 2020 12:17:32 -0000\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;From\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;ポイントタウン 【新着サービス】\u0026lt;pointmail@pointmail.com\u0026gt;\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;To\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;pointxxxx@xxxx.jp\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Message-Id\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;\u0026lt;POlSINaz.v1ZKfDxxxxx@sys-smtp51\u0026gt;\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Subject\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;【クリックP付き】♪本日の新着サービスのお知らせ♪2/28\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Return-Path\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;\u0026lt;FETPxJDawsxxxxx@post2.pointtown.com\u0026gt;\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Mime-Version\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;1.0 \u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Date\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Fri, 28 Feb 2020 21:17:29 +0900\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Content-Type\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;multipart/alternative; ～略～\u0026#34; } ], \u0026#34;commonHeaders\u0026#34;: { \u0026#34;returnPath\u0026#34;: \u0026#34;FKTPxJDawsxxxxx@post2.pointtown.com\u0026#34;, \u0026#34;from\u0026#34;: [ \u0026#34;\\\u0026#34;ポイントタウン 【新着サービス】\\\u0026#34; \u0026lt;pointmail@pointmail.com\u0026gt;\u0026#34; ], \u0026#34;date\u0026#34;: \u0026#34;Fri, 28 Feb 2020 21:17:29 +0900\u0026#34;, \u0026#34;to\u0026#34;: [ \u0026#34;pointxxxx@xxxx.jp\u0026#34; ], \u0026#34;messageId\u0026#34;: \u0026#34;\u0026lt;POlSINaz.v1ZKfDgx5e5@sys-smtp51\u0026gt;\u0026#34;, \u0026#34;subject\u0026#34;: \u0026#34;【クリックP付き】♪本日の新着サービスのお知らせ♪2/28\u0026#34; } }, \u0026#34;receipt\u0026#34;: { ～略(SNSの情報)～ } }, \u0026#34;content\u0026#34;: \u0026#34;Return-Path: \u0026lt;FKTPxJDawsxxxxx@post2.pointtown.com\u0026gt;\\r\\nReceived～略～\u0026#34; }   情報が多くてオーバーフローしそうですが…。\n必要そうな情報だけ抜いていきます。\nまず、メールの情報はmailの中。\n本文の情報はcontentの中にあります。\n本文の取り方は前回の記事を読んでいただくとして、今回は、ヘッダー情報を取得していきます。\nヘッダー取得 まず各ヘッダー情報を取得しやすいように変形します。\nなぜかね、辞書型でなくて、配列で入ってるんですよ。こいつらは…。\nなので、まず配列にします。\n1 2 3 4 5 6 7 8 9  email_header = dict(map(lambda x:(x[\u0026#34;name\u0026#34;],x[\u0026#34;value\u0026#34;]),message[\u0026#34;mail\u0026#34;][\u0026#34;headers\u0026#34;])) #タイトル print(f\u0026#39;タイトル：{email_header[\u0026#34;Subject\u0026#34;]}\u0026#39;) #To print(f\u0026#39;To：{email_header[\u0026#34;To\u0026#34;]}\u0026#39;) #From print(f\u0026#39;From：{email_header[\u0026#34;From\u0026#34;]}\u0026#39;) #Date print(f\u0026#39;Date：{email_header[\u0026#34;Date\u0026#34;]}\u0026#39;)   欲しいのはこんなところ。\nで、SNSのメッセージにこれを加えていく。\nコード 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  import json import email import boto3 def lambda_handler(event, context): print(json.dumps(event)) message = json.loads(event[\u0026#34;Records\u0026#34;][0][\u0026#34;body\u0026#34;]) print(message) email_body = message[\u0026#34;content\u0026#34;] email_object = email.message_from_string(email_body) email_header = dict(map(lambda x:(x[\u0026#34;name\u0026#34;],x[\u0026#34;value\u0026#34;]),message[\u0026#34;mail\u0026#34;][\u0026#34;headers\u0026#34;])) body = \u0026#34;\u0026#34; for part in email_object.walk(): # ContentTypeがmultipartの場合は実際のコンテンツはさらに # 中のpartにあるので読み飛ばす if part.get_content_maintype() == \u0026#39;multipart\u0026#39;: continue # ファイル名の取得 attach_fname = part.get_filename() # ファイル名がない場合は本文のはず if not attach_fname: charset = str(part.get_content_charset()) if charset: body += part.get_payload(decode=True).decode(charset, errors=\u0026#34;replace\u0026#34;) else: body += part.get_payload(decode=True) else: # ファイル名があるならそれは添付ファイルなので # データを取得する attach_file_list.append({ \u0026#34;name\u0026#34;: attach_fname, \u0026#34;data\u0026#34;: part.get_payload(decode=True) }) print(body) TOPIC_ARN = os.environ[\u0026#39;TOPIC_ARN\u0026#39;] client = boto3.client(\u0026#39;sns\u0026#39;) response = client.publish( TopicArn = TOPIC_ARN, Message = f\u0026#39;To：{email_header[\u0026#34;To\u0026#34;]}\\nFrom：{email_header[\u0026#34;From\u0026#34;]}\\nDate：{email_header[\u0026#34;Date\u0026#34;]}\\nbody\u0026#39;, Subject = f\u0026#39;メール受信:{email_header[\u0026#34;Subject\u0026#34;]}\u0026#39; ) return { \u0026#39;statusCode\u0026#39;: 200 }   テストメールを送信してみる\nうん。いい感じ。\n続きは明日。\n","description":"","id":12,"section":"posts","tags":["aws","SES","SQS","SNS","lambda"],"title":"SESでメール受信時に、タイトルと各アドレスを取得する","uri":"https://encr.jp/blog/posts/20200228_morning/"},{"content":"朝、マウント(同期)が上手くいかなかったので、リベンジ\nwindowsのdockerでは/c/xxxを見ていて、\nwslでは/c/xxxがマウントされた/mnt/c/xxxを見ている\nなんか、この辺がよくないことになっているよう…。\n前回までの流れはこちら\nただ、requirements.txtはdockerから見れているので、\nwsl\u0026mdash;\u0026gt;docker\nwsl\u0026lt;-x-docker\nってこと…。\nうーん…。\n明示的にマウントする？ 朝は↓をやってたけど、\n$ docker run --rm docker-layers:1.0 とりあえず、マウントオプション付けてみる\n-v ローカルディレクトリ:コンテナディレクトリ？\nよく分からんのよね、この辺…。\n誰かまじで、給料払うから教えてほしいww\nで、とりあえず実行してみる\n$ docker run --rm -v \u0026quot;$PWD\u0026quot;/test/:/var/task docker-layers:1.0 ERROR: Could not open requirements file: [Errno 2] No such file or directory: 'requirements.txt' あーあ、testフォルダのrequirements.txt認識されなくなっちゃった…。\n$ ls Dockerfile test ちゃんあるか確認すると、ちゃんとあるw\n$ echo $PWD /mnt/c/github/runau/lineBot/docker /mntだからいけないのかな…。\nフルパス(/c/)指定 $ docker run --rm -v /c/github/runau/lineBot/docker/test:/var/task docker-layers:1.0 Collecting httplib2 Downloading httplib2-0.17.0-py3-none-any.whl (95 kB) Collecting oauth2client Downloading oauth2client-4.1.3-py2.py3-none-any.whl (98 kB) Collecting google-api-python-client Downloading google-api-python-client-1.7.11.tar.gz (142 kB) Collecting rsa\u0026gt;=3.1.4 Downloading rsa-4.0-py2.py3-none-any.whl (38 kB) Collecting six\u0026gt;=1.6.1 Downloading six-1.14.0-py2.py3-none-any.whl (10 kB) Collecting pyasn1\u0026gt;=0.1.7 Downloading pyasn1-0.4.8-py2.py3-none-any.whl (77 kB) Collecting pyasn1-modules\u0026gt;=0.0.5 Downloading pyasn1_modules-0.2.8-py2.py3-none-any.whl (155 kB) Collecting google-auth\u0026gt;=1.4.1 Downloading google_auth-1.11.2-py2.py3-none-any.whl (76 kB) Collecting google-auth-httplib2\u0026gt;=0.0.3 Downloading google_auth_httplib2-0.0.3-py2.py3-none-any.whl (6.3 kB) Collecting uritemplate\u0026lt;4dev,\u0026gt;=3.0.0 Downloading uritemplate-3.0.1-py2.py3-none-any.whl (15 kB) Collecting setuptools\u0026gt;=40.3.0 Downloading setuptools-45.2.0-py3-none-any.whl (584 kB) Collecting cachetools\u0026lt;5.0,\u0026gt;=2.0.0 Downloading cachetools-4.0.0-py3-none-any.whl (10 kB) Building wheels for collected packages: google-api-python-client Building wheel for google-api-python-client (setup.py): started Building wheel for google-api-python-client (setup.py): finished with status 'done' Created wheel for google-api-python-client: filename=google_api_python_client-1.7.11-py3-none-any.whl size=56530 sha256=bab3a40c1bec240a47ca6cd09cef3bda865a0a6ea31d3d73e00d2f933c60b7ef Stored in directory: /root/.cache/pip/wheels/69/69/aa/24c58209ab280c154bb17a8ab37294226d776a5cc86aea03b4 Successfully built google-api-python-client ERROR: awscli 1.18.5 has requirement rsa\u0026lt;=3.5.0,\u0026gt;=3.1.2, but you'll have rsa 4.0 which is incompatible. Installing collected packages: httplib2, pyasn1, rsa, six, pyasn1-modules, oauth2client, setuptools, cachetools, google-auth, google-auth-httplib2, uritemplate, google-api-python-client Successfully installed cachetools-4.0.0 google-api-python-client-1.7.11 google-auth-1.11.2 google-auth-httplib2-0.0.3 httplib2-0.17.0 oauth2client-4.1.3 pyasn1-0.4.8 pyasn1-modules-0.2.8 rsa-4.0 setuptools-45.2.0 six-1.14.0 uritemplate-3.0.1 動いた。\nそして、データも入ったw\nやっぱり/mnt/c/xxxと/c/xxx問題か…。\n今度もう一回ちゃんとお勉強しよう…。\nとりあえず、今回は、動いたからOKww\nlambdaにデプロイ で、lambdaに上げてみる。\n$ aws cloudformation package --template-file ./template.yaml --s3-bucket $bucket_name --output-template-file $packaged_name $ aws cloudformation deploy --template-file $packaged_name --stack-name $stack_name 実行！\n動いたーーーー！\n嬉しい！長かった…。\nこれはこれからlinebotに組み込むのに使っていきます//\n","description":"","id":13,"section":"posts","tags":["Python","aws","GCP","google_calendar"],"title":"dockerでマウントする カレンダー連携⑥","uri":"https://encr.jp/blog/posts/20200227_night/"},{"content":"昨日はメモリ不足でdocker動かなかったので、今日はそのリベンジ。\n私のPCが7年前のおんぼろのせいで、dockerが要求しているメモリが確保できない問題ww\ndockerが要求しているメモリを下げる方法を考える\n前回までの流れはこちら\nメモリ減らす！ update updateしてみた。\n結果変わらず…。\nやはりsettingsにadvancedはない。\nアンインストール＆最新インストール 結果変わらず…。\nやはりsettingsにadvancedはない。\nアーカイブをさがす 結構探したけど見つからず…。\nエッジ版を入れる でた！\n起動する $ docker version Client: Version: 18.09.7 API version: 1.39 Go version: go1.10.1 Git commit: 2d0083d Built: Fri Aug 16 14:20:06 2019 OS/Arch: linux/amd64 Experimental: false Cannot connect to the Docker daemon at tcp://localhost:2375. Is the docker daemon running? ありゃりゃ…。\nまた出来なくなっちゃった…。\n~/.bashrcおかしくなったかな…。\n1  export DOCKER_HOST=tcp://localhost:2375   入ってるけどな…。\n色々調べる…。\n1 2 3  export DOCKER_HOST=tcp://localhost:2375 alias docker=\u0026#34;DOCKER_HOST=${DOCKER_HOST}docker\u0026#34; alias docker-compose=\u0026#34;docker-compose -H ${DOCKER_HOST}\u0026#34;   でなんか出てきたから、設定を追加してみるw\n$ docker stats CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS 動いたww わぁい//\nビルド 改めて…ビルド！\n$ docker build . Sending build context to Docker daemon 3.072kB Step 1/4 : FROM lambci/lambda:build-python3.8 build-python3.8: Pulling from lambci/lambda 3b0280105a32: Pull complete 838e4ce9589f: Pull complete 743fd1cfe265: Pull complete 558555681a77: Pull complete Digest: sha256:9004ec2c2724a19024f7180431b70845db46e1774c009d149d03380cafa8c143 Status: Downloaded newer image for lambci/lambda:build-python3.8 ---\u0026gt; 841c3a9e9bbe Step 2/4 : ENV AWS_DEFAULT_REGION ap-northeast-1 ---\u0026gt; Running in c246a0fc14a0 Removing intermediate container c246a0fc14a0 ---\u0026gt; 9051088345c5 Step 3/4 : ADD . . ---\u0026gt; 142a7073ec21 Step 4/4 : CMD pip3 install -r requirements.txt -t /var/task ---\u0026gt; Running in a594923a7f9c Removing intermediate container a594923a7f9c ---\u0026gt; d6262f103a5c Successfully built d6262f103a5c う、動いたー！！！！\n嬉しい///\nラン $ docker run docker-layers:1.0 Collecting httplib2 Downloading httplib2-0.17.0-py3-none-any.whl (95 kB) Collecting oauth2client Downloading oauth2client-4.1.3-py2.py3-none-any.whl (98 kB) Collecting google-api-python-client Downloading google-api-python-client-1.7.11.tar.gz (142 kB) Collecting pyasn1\u0026gt;=0.1.7 Downloading pyasn1-0.4.8-py2.py3-none-any.whl (77 kB) Collecting six\u0026gt;=1.6.1 Downloading six-1.14.0-py2.py3-none-any.whl (10 kB) Collecting rsa\u0026gt;=3.1.4 Downloading rsa-4.0-py2.py3-none-any.whl (38 kB) Collecting pyasn1-modules\u0026gt;=0.0.5 Downloading pyasn1_modules-0.2.8-py2.py3-none-any.whl (155 kB) Collecting google-auth\u0026gt;=1.4.1 Downloading google_auth-1.11.2-py2.py3-none-any.whl (76 kB) Collecting google-auth-httplib2\u0026gt;=0.0.3 Downloading google_auth_httplib2-0.0.3-py2.py3-none-any.whl (6.3 kB) Collecting uritemplate\u0026lt;4dev,\u0026gt;=3.0.0 Downloading uritemplate-3.0.1-py2.py3-none-any.whl (15 kB) Collecting cachetools\u0026lt;5.0,\u0026gt;=2.0.0 Downloading cachetools-4.0.0-py3-none-any.whl (10 kB) Collecting setuptools\u0026gt;=40.3.0 Downloading setuptools-45.2.0-py3-none-any.whl (584 kB) Building wheels for collected packages: google-api-python-client Building wheel for google-api-python-client (setup.py): started Building wheel for google-api-python-client (setup.py): finished with status 'done' Created wheel for google-api-python-client: filename=google_api_python_client-1.7.11-py3-none-any.whl size=56530 sha256=287400b420bc91aeaaec031fa357d64f3005d2c5b4b27ecdd3e39229675870d2 Stored in directory: /root/.cache/pip/wheels/69/69/aa/24c58209ab280c154bb17a8ab37294226d776a5cc86aea03b4 Successfully built google-api-python-client ERROR: awscli 1.18.5 has requirement rsa\u0026lt;=3.5.0,\u0026gt;=3.1.2, but you'll have rsa 4.0 which is incompatible. Installing collected packages: httplib2, pyasn1, six, rsa, pyasn1-modules, oauth2client, cachetools, setuptools, google-auth, google-auth-httplib2, uritemplate, google-api-python-client Successfully installed cachetools-4.0.0 google-api-python-client-1.7.11 google-auth-1.11.2 google-auth-httplib2-0.0.3 httplib2-0.17.0 oauth2client-4.1.3 pyasn1-0.4.8 pyasn1-modules-0.2.8 rsa-4.0 setuptools-45.2.0 six-1.14.0 uritemplate-3.0.1 動いた！けどファイル出来上がらない…\nマウントの問題かな…\n続きはお昼\n続き\n","description":"","id":14,"section":"posts","tags":["docker","aws","Python","GCP","google_calendar"],"title":"dockerのメモリを下げる カレンダー連携⑤","uri":"https://encr.jp/blog/posts/20200227_morning/"},{"content":"前回lambdaが動かなかったので、なんとか頑張る回ですw\nlayerが上手く固められていなかったのが原因で、多分dockerで解決するはず…。\n前回までの流れはこちら\ndocerの導入 私の開発環境はwindows on WSL です。\nなので、Docker for WindowsをWSLから呼び出していきます。\nWindows側の作業 Docker for Windowsはインストール済。\nこちらからインストールできます。\nWSL側の作業 これらもインストール済\n   ツール名 バージョン     docker 18.09.7   docker-compose 1.24.0    これを実行\necho \u0026quot;export DOCKER_HOST=tcp://localhost:2375\u0026quot; \u0026gt;\u0026gt; ~/.bashrc source ~/.bashrc 接続確認 $ docker stats CONTAINER ID NAME CPU % PRIV WORKING SET NET I/O BLOCK I/O 動いた。\nlayerを作る Dockerfileを作る 1 2 3 4  FROMlambci/lambda:build-python3.8ENV AWS_DEFAULT_REGION ap-northeast-1ADD . .CMD pip3 install -r requirements.txt -t /var/task  requirements.txtを作る 1 2 3  httplib2 oauth2client google-api-python-client   ビルドする。 $ docker build . Sending build context to Docker daemon 2.048kB Step 1/4 : FROM lambci/lambda:build-python3.8 build-python3.8: Pulling from lambci/lambda image operating system \u0026quot;linux\u0026quot; cannot be used on this platform むぅ。\n調べたら、osがlinuxになってないせいらしい。\n$ docker version Client: Version: 18.09.7 API version: 1.39 Go version: go1.10.1 Git commit: 2d0083d Built: Fri Aug 16 14:20:06 2019 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 19.03.4 API version: 1.40 (minimum version 1.24) Go version: go1.12.10 Git commit: 9013bf5 Built: Thu Oct 17 23:55:51 2019 OS/Arch: windows/amd64 Experimental: false $ docker version Client: Version: 18.09.7 API version: 1.39 Go version: go1.10.1 Git commit: 2d0083d Built: Fri Aug 16 14:20:06 2019 OS/Arch: linux/amd64 Experimental: false Cannot connect to the Docker daemon at tcp://localhost:2375. Is the docker daemon running? アイコンにカーソル合わせると、\nDocker Desktop is switching\u0026hellip;\nってでます。\nちょっと待ちましょう。\n待ってたら…\nメモリー不足…。\nメモリー下げて再挑戦…\nと思ったら、私のdocker、settingsにadvanced…。メモリの設定ないの…\nなんか色々調子悪いし、一回入れなおす！\n続きは明日…\n※追記\nメモリの設定はエッジ版をダウンロードしたら表示されました。\n詳しくは翌日記事参照\n続き\n","description":"","id":15,"section":"posts","tags":["docker","aws","google_calendar"],"title":"dockerを使ってみる カレンダー連携④","uri":"https://encr.jp/blog/posts/20200226_lunch/"},{"content":"終わりました。Twitterbot企画！\n50人近い方にリプライ頂けて感激でした//\nで、感想と反省と次回のやりたい事をまとめますww\n結果 おはようございます//\nついに！フォロワー様5000人！\nありがとうございます(*´˘`*)♡\n企画しますー！\n〆：2/25 13:00\n🙏お願い\nこのツイートにリプすると、\n⚡️お礼\nbotが貴方のツイートを3つリツイートします！#拡散希望 #RT企画\nbotのコードや作成過程はこちら↓https://t.co/wFPBep750t\n\u0026mdash; るな@エンジニア🧐2日間リツイート増えます💦直帰率3.37%のブログ運営中😜11日目28記事目 (@engineergirl_w) February 22, 2020  感想と反省  リツイートに需要はあんまりない？  特典目当てでリプしてくれる人が少なかったように思いました…。\nリツイートはそんなに求められてないのかなーなんて思いました。\nとなると、やっぱり一番いいのはブログでの紹介？？\n リプはハードルが高い？  リプライが条件だったのですが、いいねの半分くらいしかリプライがなく…。\nいいねでも参加できるようにしたい！\n 土日(しかも三連休)はTwitter人口が少ない？  なんか、いつもより、Twitter人口が少なかったように思いました。\n特に、私と繋がってくださってる方は、私と同じくサラリーマンの方が多いから、平日の仕事の合間がお暇なのかなー\n次回の企画案！ また懲りずに6000人企画をしたいと思っています！\nなぜなら楽しかったから//\n自動でこんなことができるんだ！面白い！\nって言って下さる方が、エンジニア、非エンジニア問わずいらっしゃり、とても嬉しく、楽しかったです//\nなので、パワーアップ企画をやりたいWW\n近いうちに達成してしまいそうだから、実装できたところまでを企画にさせていただきたいなって思います♡\n抽選機能 よく企業のプロモーションで見ますが、リアルタイムの抽選システム\nその場で抽選する機能付けてみたいなー\nただ、そうすると、DBで当選者の記録をとりながら企画を進める必要があります。\nみんな大好きdynamoDBと繋ごうと思ってますww\n企画参加対象アクションの拡大 今回はリプライだけが対象でしたが、リツイート、いいねも企画参加の対象にしたいなーと思ってます//\nでも、やっぱり一番してほしいのはリプライなのでww←botの感想聞きたい病ww\nリプライ5点\nいいね1点\nリツイート3点\n引用リツイート4点\nくらいで点数付けをして、点数に確立を掛けて、抽選してみたいな…\n作成のための機能追加順！ 他にもやりたい事がたくさんあるので、この企画botばっかりに手を掛けられません…。\nいつでもリリースできるように、少しづつ機能追加していって、いつでもリリースできるようにしたいと思いますww\nなので、機能ごとに追加順を細かく決めて、それぞれを作っていきますー\n いいねを参加アクションに追加 リツイートを参加アクションに追加 引用リツイートを参加アクションに追加 抽選機能 (特賞：ブログでの紹介、1等：Twitterでの紹介、2等：リツイート3つ、1等：リツイート1つ。とかかなー) 抽選結果をdynamoに格納  あれ？完成したな？\n一日一個やれば、5日で完成するなww\nちょっと今日は、googleカレンダー連携を進めたいので出来ませんが、明日からちょこちょこ進めていきます//\n朝活はここまで！会社行こうー！\n","description":"","id":16,"section":"posts","tags":["Python","twitter","aws","twitter_api"],"title":"次回企画に向けて！抽選する。dynamoと繋ぐ。色々やりたい！ twitterBot⑧","uri":"https://encr.jp/blog/posts/20200226_morning/"},{"content":"ついに本題ですw\n昨日ローカルから実行したpythonをlambdaに上げていきます！\n前回までの流れはこちら\nlayers作成 昨日pip installしたこの子達をlayersに固めていきます。\npip install -t . httplib2 pip install -t . oauth2client pip install -t . google-api-python-client で、cloudformationでデプロイ\ntemplateはこちら\nAWSTemplateFormatVersion: '2010-09-09' Transform: 'AWS::Serverless-2016-10-31' Description: api gw, lambda, layers and sqs Parameters: Env: Type: String Default: dev Resources: getGoogleCalendar: Type: 'AWS::Serverless::Function' Properties: FunctionName: !Sub 'getGoogleCalendar-${Env}' Handler: lambda_function.lambda_handler Runtime: python3.7 CodeUri: src/getGoogleCalendar Description: !Sub 'getGoogleCalendar-${Env}' Environment: Variables: ENV: !Sub ${Env} MemorySize: 1024 Timeout: 60 Role: !Sub 'arn:aws:iam::${AWS::AccountId}:role/service-role/slackBotRole' Tags: Env: dev project: lineBot Layers: - !Ref layerGcp layerGcp: Type: AWS::Serverless::LayerVersion Properties: Description: python modules Layer ContentUri: ./layer/gcp CompatibleRuntimes: - python3.7 - python3.6 で、デプロイ\nコンソールからテスト実行。\nうーん…。\nこれは、ただのpip install -tではだめなやつかも…。\ndockerさんの出番のやつかな…。\n続きは夜！\n続き\n","description":"","id":17,"section":"posts","tags":["Python","aws","GCP","google_calendar"],"title":"googleカレンダー取得スクリプトをlambdaに載せる カレンダー連携③","uri":"https://encr.jp/blog/posts/20200225_morning/"},{"content":"昨日は最初の最初で終わってしまったので、今日はなんとしても取得するまで頑張る！！\nひきつづきこちらの記事を元に進めていく。\n前回までの流れはこちら\nGCPのIAM設定 サービスアカウントからサービスアカウントを作成する。\nきっとawsのユーザー作る感じなんだろうかね？\n指示通りに進める。\nとりあえずオーナー権限を付けておけという事らしい。\n指示通りに「+キーを作成」を押すと、こんなファイルがダウンロードされた。\nで、アカウント作成がおわると、こんな感じになって、カレンダーapiに作ったアカウントがマッピングされたみたい。\nで、↑の「サービスアカウント」の「メール」のメールアドレスみたいなやつをコピーして、連携したいカレンダーの共有を許可する。\n多分awsでのiamが、gcpではメールアドレスっぽい感じになっているのかなと思った\nこれで、GCPの設定はおしまい。\nとりあえずローカルで叩く awsのlambdaに上げる前にとりあえずローカルで動かす。\nまず、これらが必要らしいので、pipでinstallする。\nもちろんまとめてやって大丈夫です。\nエラー出ないかハラハラしながらやったので、一個ずつ。\nだって2とか付いてるとpython2用のライブラリかと思うじゃん？\nなんかね、問題なかったww\npip install httplib2 pip install oauth2client pip install google-api-python-client で、コードをコピペ。\nそしたらね、ここの記事のソース、ファンクションしかなかったw\n呼び出し部分を作る。\nまぁ、呼び出すだけなんだけどw\ncal = GoogleCalendar() print(cal.get_schedule(\u0026quot;xxxxx@gmail.com\u0026quot;,\u0026quot;2017-01-15T12:24:07+09:00\u0026quot;,\u0026quot;2017-01-23T12:24:07+09:00\u0026quot;)) で、get_schedule(calendar_id, time_min, time_max)ね。\ncalendar_id：基本的に個人のカレンダーなら、その人のメールアドレス\ntime_min、time_max：いつからいつまでのデータを取得するかを指定。形式は文字列でこの形。\u0026ldquo;2017-01-15T12:24:07+09:00\u0026rdquo;\nちなみに、どれか間違ってるとこんな感じのエラーが出るw\nよく調べもせずに実行するもんだから、どっちも出たww\n$python lambda_function.py Traceback (most recent call last): File \u0026quot;lambda_function.py\u0026quot;, line 45, in get_schedule singleEvents=True File \u0026quot;/home/lisa/.pyenv/versions/3.6.5/lib/python3.6/site-packages/googleapiclient/_helpers.py\u0026quot;, line 130, in positional_wrapper return wrapped(*args, **kwargs) File \u0026quot;/home/lisa/.pyenv/versions/3.6.5/lib/python3.6/site-packages/googleapiclient/http.py\u0026quot;, line 856, in execute raise HttpError(resp, content, uri=self.uri) googleapiclient.errors.HttpError: \u0026lt;HttpError 404 when requesting https://www.googleapis.com/calendar/v3/calendars/適当ww/events?timeMin=2017-01-15T12%3A24%3A07%2B09%3A00\u0026amp;timeMax=2017-01-23T12%3A24%3A07%2B09%3A00\u0026amp;singleEvents=true\u0026amp;alt=json returned \u0026quot;Not Found\u0026quot;\u0026gt; None ↑カレンダーid適当に設定したとき\n$python lambda_function.py Traceback (most recent call last): File \u0026quot;lambda_function.py\u0026quot;, line 45, in get_schedule singleEvents=True File \u0026quot;/home/lisa/.pyenv/versions/3.6.5/lib/python3.6/site-packages/googleapiclient/_helpers.py\u0026quot;, line 130, in positional_wrapper return wrapped(*args, **kwargs) File \u0026quot;/home/lisa/.pyenv/versions/3.6.5/lib/python3.6/site-packages/googleapiclient/http.py\u0026quot;, line 856, in execute raise HttpError(resp, content, uri=self.uri) googleapiclient.errors.HttpError: \u0026lt;HttpError 400 when requesting https://www.googleapis.com/calendar/v3/calendars/xxxxxxxx%40gmail.com/events?timeMin=2020-02-17+22%3A51%3A32.064281\u0026amp;timeMax=2020-03-02+22%3A51%3A32.064349\u0026amp;singleEvents=true\u0026amp;alt=json returned \u0026quot;Bad Request\u0026quot;\u0026gt; None ↑これは、datetime渡した時ww\n正しく叩けたらこんな感じでjsonが返ってくる！やったぁー！\n$ python lambda_function.py [ { \u0026quot;kind\u0026quot;: \u0026quot;calendar#event\u0026quot;, \u0026quot;etag\u0026quot;: \u0026quot;296421908588xxxx\u0026quot;, \u0026quot;id\u0026quot;: \u0026quot;9su49ajtsgsm0jdbhvri79xxxx\u0026quot;, \u0026quot;status\u0026quot;: \u0026quot;confirmed\u0026quot;, \u0026quot;htmlLink\u0026quot;: \u0026quot;https://www.google.com/calendar/event?eid=xxx\u0026quot;, \u0026quot;created\u0026quot;: \u0026quot;2016-12-10T03:59:55.000Z\u0026quot;, \u0026quot;updated\u0026quot;: \u0026quot;2016-12-19T01:05:42.941Z\u0026quot;, \u0026quot;summary\u0026quot;: \u0026quot;有給消化\u0026quot;, \u0026quot;creator\u0026quot;: { \u0026quot;email\u0026quot;: \u0026quot;xxxxx@gmail.com\u0026quot;, \u0026quot;displayName\u0026quot;: \u0026quot;ユーザー名\u0026quot;, \u0026quot;self\u0026quot;: true }, \u0026quot;organizer\u0026quot;: { \u0026quot;email\u0026quot;: \u0026quot;xxxxx@gmail.com\u0026quot;, \u0026quot;displayName\u0026quot;: \u0026quot;ユーザー名\u0026quot;, \u0026quot;self\u0026quot;: true }, \u0026quot;start\u0026quot;: { \u0026quot;date\u0026quot;: \u0026quot;2016-12-22\u0026quot; }, \u0026quot;end\u0026quot;: { \u0026quot;date\u0026quot;: \u0026quot;2017-02-03\u0026quot; }, \u0026quot;transparency\u0026quot;: \u0026quot;transparent\u0026quot;, \u0026quot;iCalUID\u0026quot;: \u0026quot;9su49ajtsgsm0jdbhvri79xxxx@google.com\u0026quot;, \u0026quot;sequence\u0026quot;: 1, \u0026quot;reminders\u0026quot;: { \u0026quot;useDefault\u0026quot;: false } }, { ～略～ ] う…。もうこんな時間だ…\nとりあえず取得は出来たから、続きは明日にしよう…。\nおやすみなさい。\n続き\n","description":"","id":18,"section":"posts","tags":["GCP","google_calendar","Python"],"title":"スケジュールを取得する！ カレンダー連携②","uri":"https://encr.jp/blog/posts/20200224_morning/"},{"content":"今日はgoogle Calendarを連携する方法を考えます！\n一番最終的なゴールは、「dynamoに登録されたカレンダー情報を元にlambdaでカレンダーから情報を取得、更新する」ことです。\nまずは、そのために、連携方法を色々考える\ngoogle Calendar取得の方法 予定を追加するだけならurlを指定するだけでいいとか、icsファイルをなんかすればいいらしいんだけど、今回したいのは、取得も込みなので、まずは取得出来る方法を考える。\ngoogleAPI 検索したら、もろやりたかったことが出てきた。\n個人のGoogleカレンダーの予定をPythonで取得する\nありがたいねー\nネットは偉大だねぇ。\n私も誰かに同じように使ってもらえたら嬉しいなーww\nそれはさておき、とりあえず、この通りのことをやってみる！\nGoogle API ConsoleでCalendarAPIのサービスアカウントを発行 Google APIアカウント自体は前に作っていたから、それを使う。\nGoogle API Console\nところで、Google APIとgasって別物か？google初心者の私に誰か教えてww\nあぁ、このブログコメントないからな…。コメント付けたいな…。\n明日余裕があったら付けよう…。\n新規プロジェクト作成\n出来上がったら、↓のように、そのプロジェクトを選択して、「APIとサービスを有効化」する。\nで、API「Calendar API」を検索\nCalendar APIを選択\n有効にする。\n指示通りに認証情報を作成する\nよく分かんないから、とりあえず↑サイトの手順通りに進める\nと思ったけど、ご飯の時間だ…。\nまだまだ途中だけど…。とりあえずここまでup。\n続きは明日\n","description":"","id":19,"section":"posts","tags":["GCP","google_calendar"],"title":"google Calendarで遊んでみる カレンダー連携①","uri":"https://encr.jp/blog/posts/20200223_night/"},{"content":"フォロワー様5000人を記念して、企画botを作りました。\n企画ツイートにリプしてくれたら、御礼のリプライと、その人の最近のツイートを3件リツイートするよー！って企画w\n面白いって参加してくださる方がたくさんいて、もうすごい嬉しい//\n開始から3時間くらいだけど、20人くらいの方に参加いただけて…。\nありがとうございます！\nここまでの作成過程なんかはこちら。\nおはようございます//\nついに！フォロワー様5000人！\nありがとうございます(*´˘`*)♡\n企画しますー！\n〆：2/25 13:00\n🙏お願い\nこのツイートにリプすると、\n⚡️お礼\nbotが貴方のツイートを3つリツイートします！#拡散希望 #RT企画\nbotのコードや作成過程はこちら↓https://t.co/wFPBep750t\n\u0026mdash; るな@エンジニア🧐2日間リツイート増えます💦直帰率3.37%のブログ運営中😜11日目28記事目 (@engineergirl_w) February 22, 2020  で、実際に使ってもらうとバグがでるでるww\n知ってたけどw\nなので、調整入れていきます！\n各種エラーの対応 名前の切り抜き twitterって140文字しかつぶやけないんですね。\nなので、それ以上のツイートをしようとすると、こんなエラーが返ってくる\n{'errors': [{'code': 186, 'message': 'Tweet needs to be a bit shorter.'}]} 御礼のリプライメッセージはこちら。\n1  status = f\u0026#39;{reply[\u0026#34;name\u0026#34;]}さん、企画に参加ありがとうございます！\\nリプの御礼に{reply[\u0026#34;name\u0026#34;]}さんのツイートを最新から3件ほど、RTさせて頂きます♡\\n何回でも参加可能なので、またのご参加お待ちしております！\\n\\n※このツイートはbotからの自動送信です\u0026#39;   名前抜きで、108文字もある💦\nなので、許容できる文字数は15文字ってところですねww\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #名前の切り抜き for idx,r in enumerate(replyList): name = replyList[idx][\u0026#34;name\u0026#34;] name = name.split(\u0026#34;@\u0026#34;)[0] name = name.split(\u0026#34;\u0026#34;)[0] name = name.split(\u0026#34;\u0026#34;)[0] name = name.split(\u0026#34;｜\u0026#34;)[0] #空になってしまったら、元々の名前を復活 if len(name) == 0: name = replyList[idx][\u0026#34;name\u0026#34;] #切り抜いた結果of切り抜けなかった結果15文字以内なら文字数で切り取り if len(name) \u0026lt;= 15: replyList[idx][\u0026#34;name\u0026#34;] = name else: replyList[idx][\u0026#34;name\u0026#34;] = f\u0026#34;{name[0:15]}…\u0026#34;   で、こんなのを追加してみました。\nやっぱり名前の区切り文字で一番使われてるのは@ですよね。\nあとスペースとか、メジャーな区切り文字の方はしっかり区切ってあげます。\nで、切り取れなかった人や、切り取っても長い人は、15文字でバサッと切って、略してるよーって伝えるためにw点をくっつけておきます！\nはい、完成。\nツイートが検出出来ない人への対応 Twitterって莫大な量のツイートが蓄積されるから、私たち一般人がapiを使うと最近一週間分のデータしか取れない。みたいな制限があるんですって。\nあんまりツイートしない人だと、3ツイートも取得できないww\nで、うん、これはもはやただのバグですが…。\nTraceback (most recent call last): File \u0026quot;/var/task/lambda_function.py\u0026quot;, line 165, in lambda_handler main() File \u0026quot;/var/task/lambda_function.py\u0026quot;, line 155, in main print(f'{reply[\u0026quot;tweetIdList\u0026quot;][idx]}をリツイート') IndexError: list index out of range はぁ…。\nない配列取ろうとしてますからね…。素人かっていうね…。\n1 2  if idx \u0026gt;= len(reply[\u0026#34;tweetIdList\u0026#34;]): break   はい。制御かけましたよ…。\n各種改善 wait追加 リツイートとリプライをしているわけなのですが、waitもいれずにバシバシリツイートするのはどうなのよ？\nって思ったので、wait追加しました。\n sleepTime = random.random() * 20 print(sleepTime) time.sleep(sleepTime) ざつーな感じw\n0～1の乱数に20掛けてるから、0秒から20秒waitします。\nngになった人へのリプライ 変なツイートをリプライしたくないので、最低限のチェックを掛けていたんですが、そうすると、チェックに引っかかってリプライされてないのか、なんらかのえらーなのかが分からない…。\n困るので、あなたはngのためリツイートできませんっていうリプライをすることにした。\n1 2 3 4  if reply[\u0026#34;ng\u0026#34;]: status = f\u0026#39;{reply[\u0026#34;name\u0026#34;]}さん、企画に参加ありがとうございます！\\n大変申し訳ありませんが、{reply[\u0026#34;ngReason\u0026#34;]}のため、{reply[\u0026#34;name\u0026#34;]}さんのツイートはRTできません。\\n\\n※このツイートはbotからの自動送信です\u0026#39; else: status = f\u0026#39;{reply[\u0026#34;name\u0026#34;]}さん、企画に参加ありがとうございます！\\nリプの御礼に{reply[\u0026#34;name\u0026#34;]}さんのツイートを最新から3件ほど、RTさせて頂きます♡\\n何回でも参加可能なので、またのご参加お待ちしております！\\n\\n※このツイートはbotからの自動送信です\u0026#39;   こんな感じ\n完成！ githubにも後で上げますー\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191  from requests_oauthlib import OAuth1Session, OAuth1 import requests import json import codecs import time import os import datetime import collections import re import random OAUTH1 = os.environ[\u0026#39;OAUTH1\u0026#39;] OAUTH2 = os.environ[\u0026#39;OAUTH2\u0026#39;] OAUTH3 = os.environ[\u0026#39;OAUTH3\u0026#39;] OAUTH4 = os.environ[\u0026#39;OAUTH4\u0026#39;] SCREEN_NAME = os.environ[\u0026#39;SCREEN_NAME\u0026#39;] def getOauth(): return OAuth1(OAUTH1, OAUTH2, OAUTH3, OAUTH4) def main(): ngList=[\u0026#34;融資\u0026#34;,\u0026#39;裏垢\u0026#39;,\u0026#39;xxx\u0026#39;,\u0026#39;yyy\u0026#39;] #ブログを汚したくないから書いていないけど、実際には、あと100ワードくらいありますwww #自分宛のリプライ最新から10件を全て取得 response = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/mentions_timeline.json?count=20\u0026#39;, auth=getOauth() ).json() #その中から、指定した元ツイートに対してのリプライのみに絞り込む in_reply_to_status_id=1231358267516809216 response = list(filter(lambda x:x[\u0026#34;in_reply_to_status_id\u0026#34;] == in_reply_to_status_id,response)) #未リプライの物のみに絞り込む doneList = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name={SCREEN_NAME}\u0026amp;count=100\u0026#39;, auth=getOauth() ).json() doneList = list(map(lambda x:x[\u0026#34;in_reply_to_status_id\u0026#34;],doneList)) print(doneList) response = list(filter(lambda x:x[\u0026#34;id\u0026#34;] not in doneList,response)) print(response) #扱いやすいように成型 replyList = list(map(lambda x:{\u0026#34;id\u0026#34;:x[\u0026#34;user\u0026#34;][\u0026#34;id\u0026#34;],\u0026#34;name\u0026#34;:x[\u0026#34;user\u0026#34;][\u0026#34;name\u0026#34;],\u0026#34;profile\u0026#34;:x[\u0026#34;user\u0026#34;][\u0026#34;description\u0026#34;],\u0026#34;replyId\u0026#34;:x[\u0026#34;id\u0026#34;],\u0026#34;ng\u0026#34;:False},response)) print(replyList) #名前の切り抜き for idx,r in enumerate(replyList): name = replyList[idx][\u0026#34;name\u0026#34;] name = name.split(\u0026#34;@\u0026#34;)[0] name = name.split(\u0026#34;｜\u0026#34;)[0] #空になってしまったら、元々の名前を復活 if len(name) == 0: name = replyList[idx][\u0026#34;name\u0026#34;] #切り抜いた結果of切り抜けなかった結果15文字以内なら文字数で切り取り if len(name) \u0026lt;= 15: replyList[idx][\u0026#34;name\u0026#34;] = name else: replyList[idx][\u0026#34;name\u0026#34;] = f\u0026#34;{name[0:15]}…\u0026#34; #最新のツイートを10件取得する option = \u0026#39;count=10\u0026amp;exclude_replies=true\u0026amp;include_rts=false\u0026#39; for idx,r in enumerate(replyList): user_timeline = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/user_timeline.json?id={r[\u0026#34;id\u0026#34;]}\u0026amp;{option}\u0026#39;, auth=getOauth() ).json() replyList[idx][\u0026#34;tweetList\u0026#34;] = list(map(lambda x:x[\u0026#34;text\u0026#34;],user_timeline)) replyList[idx][\u0026#34;tweetIdList\u0026#34;] = list(map(lambda x:x[\u0026#34;id\u0026#34;],user_timeline)) print(replyList) #NGワードチェック print(\u0026#34;NGワードチェック\u0026#34;) for idx,reply in enumerate(replyList): #プロフィールをチェック if len(list(filter(lambda ng:ng in reply[\u0026#34;profile\u0026#34;],ngList))): print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) print(list(filter(lambda ng:ng in reply[\u0026#34;profile\u0026#34;],ngList))) replyList[idx][\u0026#34;ng\u0026#34;] = True replyList[idx][\u0026#34;ngReason\u0026#34;] = \u0026#34;プロフィールにNGワードが含まれている\u0026#34; elif len(list(filter(lambda x:len(list(filter(lambda ng:ng in x,ngList))),reply[\u0026#34;tweetList\u0026#34;]))): print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) print(list(filter(lambda x:len(list(filter(lambda ng:ng in x,ngList))),reply[\u0026#34;tweetList\u0026#34;]))) replyList[idx][\u0026#34;ng\u0026#34;] = True replyList[idx][\u0026#34;ngReason\u0026#34;] = \u0026#34;ツイートにNGワードが含まれている\u0026#34; else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;) #リンク数チェック print(\u0026#34;リンク数チェック\u0026#34;) for idx,reply in enumerate(replyList): #ツイートをチェック if len(list(filter(lambda x:x.count(\u0026#34;http\u0026#34;)\u0026gt;=2,reply[\u0026#34;tweetList\u0026#34;]))): print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) replyList[idx][\u0026#34;ng\u0026#34;] = True replyList[idx][\u0026#34;ngReason\u0026#34;] = \u0026#34;ツイートに過剰なリンクがある\u0026#34; else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;) #重複リンク数チェック print(\u0026#34;重複リンク数チェック\u0026#34;) pattern = \u0026#34;https?://[\\w/:%#\\$\u0026amp;\\?\\(\\)~\\.=\\+\\-]+\u0026#34; for idx,reply in enumerate(replyList): #urlを抽出 ※既に1ツイート内に複数urlある場合は除外しているので、ここに来た時には、必ず1ツイート0～1url #まずurlを含むものだけに絞る urlTweetList =list(filter(lambda x:x.count(\u0026#34;http\u0026#34;)==1,reply[\u0026#34;tweetList\u0026#34;])) print(f\u0026#34;urlTweetList:{urlTweetList}\u0026#34;) #urlを抽出 urlList = list(map(lambda x:re.findall(pattern, x)[0],urlTweetList)) print(f\u0026#34;urlList:{urlList}\u0026#34;) #urlListのそれぞれのurlの出現回数をカウントしてくれる ※要import collections counter = collections.Counter(urlList) print(f\u0026#34;counter:{counter}\u0026#34;) if len(list(filter(lambda x:x \u0026gt;= 3,counter.values()))): print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) replyList[idx][\u0026#34;ng\u0026#34;] = True replyList[idx][\u0026#34;ngReason\u0026#34;] = \u0026#34;ツイートに過剰な重複リンクがある\u0026#34; else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;) warnList = [\u0026#34;RT企画\u0026#34;,\u0026#34;固定ツイート\u0026#34;,\u0026#34;固ツイ\u0026#34;,\u0026#34;リツイート\u0026#34;] #RT企画数チェック print(\u0026#34;RT企画数チェック\u0026#34;) for idx,reply in enumerate(replyList): if len(list(filter(lambda x:len(list(filter(lambda warn:warn in x,warnList))),reply[\u0026#34;tweetList\u0026#34;]))) \u0026gt;= 3: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) replyList[idx][\u0026#34;ng\u0026#34;] = True replyList[idx][\u0026#34;ngReason\u0026#34;] = \u0026#34;過剰なRT企画ツイートがある\u0026#34; else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;) #日本語チェック print(\u0026#34;日本語チェック\u0026#34;) pattern = \u0026#34;[\\u3041-\\u309F]+\u0026#34; #ひらがな for idx,reply in enumerate(replyList): print(re.findall(pattern, reply[\u0026#34;profile\u0026#34;])) if len(re.findall(pattern, reply[\u0026#34;profile\u0026#34;])) == 0: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) replyList[idx][\u0026#34;ng\u0026#34;] = True replyList[idx][\u0026#34;ngReason\u0026#34;] = \u0026#34;プロフィールから日本語が検出できない\u0026#34; else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;) #リプライする for reply in replyList: if reply[\u0026#34;ng\u0026#34;]: status = f\u0026#39;{reply[\u0026#34;name\u0026#34;]}さん、企画に参加ありがとうございます！\\n大変申し訳ありませんが、{reply[\u0026#34;ngReason\u0026#34;]}のため、{reply[\u0026#34;name\u0026#34;]}さんのツイートはRTできません。\\n\\n※このツイートはbotからの自動送信です\u0026#39; else: status = f\u0026#39;{reply[\u0026#34;name\u0026#34;]}さん、企画に参加ありがとうございます！\\nリプの御礼に{reply[\u0026#34;name\u0026#34;]}さんのツイートを最新から3件ほど、RTさせて頂きます♡\\n何回でも参加可能なので、またのご参加お待ちしております！\\n\\n※このツイートはbotからの自動送信です\u0026#39; in_reply_to_status_id = reply[\u0026#34;replyId\u0026#34;] print(f\u0026#34;in_reply_to_status_id:{in_reply_to_status_id} exec\u0026#34;) replyResponse = requests.post( f\u0026#39;https://api.twitter.com/1.1/statuses/update.json\u0026#39;, data={\u0026#34;status\u0026#34;:status ,\u0026#34;in_reply_to_status_id\u0026#34;:in_reply_to_status_id ,\u0026#34;auto_populate_reply_metadata\u0026#34;:True}, auth=getOauth() ).json() print(replyResponse) #リツイートする if not reply[\u0026#34;ng\u0026#34;]: for idx in range(3): if idx \u0026gt;= len(reply[\u0026#34;tweetIdList\u0026#34;]): break sleepTime = random.random() * 20 print(sleepTime) time.sleep(sleepTime) print(f\u0026#39;{reply[\u0026#34;tweetIdList\u0026#34;][idx]}をリツイート\u0026#39;) response = requests.post( f\u0026#39;https://api.twitter.com/1.1/statuses/retweet/{reply[\u0026#34;tweetIdList\u0026#34;][idx]}.json\u0026#39;, auth=getOauth() ).json() print(response) def lambda_handler(event, context): try: main() except: import traceback traceback.print_exc()   まだまだ、リプお待ちしてますー//\n","description":"","id":20,"section":"posts","tags":["Python","twitter","aws","twitter_api"],"title":"リツイート企画botを作って twitterBot⑦","uri":"https://encr.jp/blog/posts/20200223_lunch/"},{"content":"今更ですが、このブログの仕組みを解説したいと思います。\nこのブログはhugoという静的サイトジェネレーターで作られています。\nおかけでレンタルサーバーいらずでブログが公開できるんです。\nだからサーバーダウンもないし、サーバー費用もない！\n最高//\nサーバーの話 動的サイト、静的サイトとはなんぞ？という話\n動的webサイト(wordpressなど)の仕組み Wordpressが有名ですね。\n一般的なwebサイトはだいたいこの仕組みで動いています。\nPHP(wordpress),Ruby,java…などで動いているものですね。\nなので、DBもあるレンタルサーバーを借りる必要があります。\nで、それぞれがそれぞれ用に用意されるため、レンタルサーバー側は、こういう感じでサーバーを用意して、レンタルしています。\nそれぞれ用意するため、負担が大きく、従って料金も高くなるんですねー\nロリポップ！\n一番安いので、↑のロリポップかなと思いますが、それでも月250円かかります…。\nで、この250円のプランはやっすいサーバーを貸しているので、本当によく落ちます…。月に2回くらいwwほんとにww\n落ちることが多いとSEO下げられるので、最低500円のスタンダートプランくらいは欲しいですね…！\n静的webサイト(hugoなど)の仕組み 対して、hugoは、このような仕組みで動いています。\nDBサーバー、アプリケーションサーバーがいらない。\nファイルをおいておくだけでいいんです！\nしかも、このファイルサーバーというのは、皆で共有のものになり、一人一人に用意がいらないんです。\nこんな感じ。\nなので、びっくりするほど安い！\nしかもロリポップなんかのサーバーとは性能が違うから早い！\n私はawsのs3を使っています。\n今月の私の利用料金↑は3円ですww\nで、当然のことながら、12日間運用して、一度も落ちてません！\nうーん、サーバーレス最高！\nで、route53という、独自ドメインを使うための機能が別で60円くらいかかっていて、合計して63円というところです。\nなにこれ、ちょっといいじゃん！作りたい！\nって思った方は、こちらにhugoブログの作り方や、作るうえでの注意点等まとめています。\nよかったら合わせてご覧ください//\n独り言 絵書くの大変だったから、朝活はここまで(´ω｀)\ntwitterbotのバグ修正したら、もう少しサーバーレスのよさについて書いていこうかな\n※ちょっと追記しました。久しぶりにたくさん絵書いたww\n","description":"","id":21,"section":"posts","tags":["hugo","aws"],"title":"hugoブログのサーバーの仕組み　なぜ60円でブログが作れるのか？","uri":"https://encr.jp/blog/posts/20200223_morning/"},{"content":"前回の続き。\nこれで最後！自動リツイートを考えます。\nリツイートの仕方 POST statuses/retweet/:id - リツイートを実行する\nこれを使ってみる。\n1 2 3 4 5  response = requests.post( f\u0026#39;https://api.twitter.com/1.1/statuses/retweet/1231087256556859000.json\u0026#39;, auth=getOauth() ).json() print(json.dumps(response, ensure_ascii=False, indent=4))   できた！\n取得したツイートからリプライとリツイートを除外する 前回まで取得していた最近のツイート10個にはリプライとリツイートが含まれる。\nリプライとリツイートをリツイートしたくないので、リツイート対象から除外する。\nオプションを付けるだけでいいみたい。\nツイート取得時にオプションを追加する。\nで、リツイートする時にID必要だから、IDも保持しておくようにする。\n1 2 3 4 5 6 7 8 9 10 11  #最新のツイートを10件取得する option = \u0026#39;count=10\u0026amp;exclude_replies=true\u0026amp;include_rts=false\u0026#39; for idx,r in enumerate(replyList): user_timeline = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/user_timeline.json?id={r[\u0026#34;id\u0026#34;]}\u0026amp;{option}\u0026#39;, auth=getOauth() ).json() replyList[idx][\u0026#34;tweetList\u0026#34;] = list(map(lambda x:x[\u0026#34;text\u0026#34;],user_timeline)) replyList[idx][\u0026#34;tweetIdList\u0026#34;] = list(map(lambda x:x[\u0026#34;id\u0026#34;],user_timeline)) print(json.dumps(replyList, ensure_ascii=False, indent=4))   組み合わせる 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152  from requests_oauthlib import OAuth1Session, OAuth1 import requests import json import codecs import time import os import datetime import collections import re OAUTH1 = os.environ[\u0026#39;OAUTH1\u0026#39;] OAUTH2 = os.environ[\u0026#39;OAUTH2\u0026#39;] OAUTH3 = os.environ[\u0026#39;OAUTH3\u0026#39;] OAUTH4 = os.environ[\u0026#39;OAUTH4\u0026#39;] SCREEN_NAME = os.environ[\u0026#39;SCREEN_NAME\u0026#39;] def getOauth(): return OAuth1(OAUTH1, OAUTH2, OAUTH3, OAUTH4) def main(): #自分宛のリプライ最新から10件を全て取得 response = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/mentions_timeline.json?count=10\u0026#39;, auth=getOauth() ).json() #その中から、指定した元ツイートに対してのリプライのみに絞り込む in_reply_to_status_id=1231087256556859300 response = list(filter(lambda x:x[\u0026#34;in_reply_to_status_id\u0026#34;] == in_reply_to_status_id,response)) #未リプライの物のみに絞り込む doneList = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name={SCREEN_NAME}\u0026#39;, auth=getOauth() ).json() doneList = list(map(lambda x:x[\u0026#34;in_reply_to_status_id\u0026#34;],doneList)) print(json.dumps(doneList, ensure_ascii=False, indent=4)) response = list(filter(lambda x:x[\u0026#34;id\u0026#34;] not in doneList,response)) print(json.dumps(response, ensure_ascii=False, indent=4)) #扱いやすいように成型 replyList = list(map(lambda x:{\u0026#34;id\u0026#34;:x[\u0026#34;user\u0026#34;][\u0026#34;id\u0026#34;],\u0026#34;name\u0026#34;:x[\u0026#34;user\u0026#34;][\u0026#34;name\u0026#34;].split(\u0026#34;@\u0026#34;)[0],\u0026#34;profile\u0026#34;:x[\u0026#34;user\u0026#34;][\u0026#34;description\u0026#34;],\u0026#34;replyId\u0026#34;:x[\u0026#34;id\u0026#34;]},response)) print(json.dumps(replyList, ensure_ascii=False, indent=4)) #最新のツイートを10件取得する option = \u0026#39;count=10\u0026amp;exclude_replies=true\u0026amp;include_rts=false\u0026#39; for idx,r in enumerate(replyList): user_timeline = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/user_timeline.json?id={r[\u0026#34;id\u0026#34;]}\u0026amp;{option}\u0026#39;, auth=getOauth() ).json() replyList[idx][\u0026#34;tweetList\u0026#34;] = list(map(lambda x:x[\u0026#34;text\u0026#34;],user_timeline)) replyList[idx][\u0026#34;tweetIdList\u0026#34;] = list(map(lambda x:x[\u0026#34;id\u0026#34;],user_timeline)) print(json.dumps(replyList, ensure_ascii=False, indent=4)) #NGワードチェック print(\u0026#34;NGワードチェック\u0026#34;) ngList=[\u0026#34;融資\u0026#34;,\u0026#34;裏垢\u0026#34;] #ブログを汚したくないから書いていないけど、実際には、あと100ワードくらいありますwww for idx,reply in enumerate(replyList): #プロフィールをチェック if len(list(filter(lambda ng:ng in reply[\u0026#34;profile\u0026#34;],ngList))) or \\ len(list(filter(lambda x:len(list(filter(lambda ng:ng in x,ngList))),reply[\u0026#34;tweetList\u0026#34;]))): print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) replyList.pop(idx) else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;) #リンク数チェック print(\u0026#34;リンク数チェック\u0026#34;) for idx,reply in enumerate(replyList): #ツイートをチェック if len(list(filter(lambda x:x.count(\u0026#34;http\u0026#34;)\u0026gt;=2,reply[\u0026#34;tweetList\u0026#34;]))): print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) #replyList.pop(idx) else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;) #重複リンク数チェック print(\u0026#34;重複リンク数チェック\u0026#34;) pattern = \u0026#34;https?://[\\w/:%#\\$\u0026amp;\\?\\(\\)~\\.=\\+\\-]+\u0026#34; for idx,reply in enumerate(replyList): #urlを抽出 ※既に1ツイート内に複数urlある場合は除外しているので、ここに来た時には、必ず1ツイート0～1url #まずurlを含むものだけに絞る urlTweetList =list(filter(lambda x:x.count(\u0026#34;http\u0026#34;)==1,reply[\u0026#34;tweetList\u0026#34;])) print(f\u0026#34;urlTweetList:{urlTweetList}\u0026#34;) #urlを抽出 urlList = list(map(lambda x:re.findall(pattern, x)[0],urlTweetList)) print(f\u0026#34;urlList:{urlList}\u0026#34;) #urlListのそれぞれのurlの出現回数をカウントしてくれる ※要import collections counter = collections.Counter(urlList) print(f\u0026#34;counter:{counter}\u0026#34;) if len(list(filter(lambda x:x \u0026gt;= 3,counter.values()))): print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) replyList.pop(idx) else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;) warnList = [\u0026#34;RT企画\u0026#34;,\u0026#34;固定ツイート\u0026#34;,\u0026#34;固ツイ\u0026#34;,\u0026#34;リツイート\u0026#34;] #RT企画数チェック print(\u0026#34;RT企画数チェック\u0026#34;) for idx,reply in enumerate(replyList): if len(list(filter(lambda x:len(list(filter(lambda warn:warn in x,warnList))),reply[\u0026#34;tweetList\u0026#34;]))) \u0026gt;= 3: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) replyList.pop(idx) else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;) #日本語チェック print(\u0026#34;日本語チェック\u0026#34;) pattern = \u0026#34;[\\u3041-\\u309F]+\u0026#34; #ひらがな for idx,reply in enumerate(replyList): print(re.findall(pattern, reply[\u0026#34;profile\u0026#34;])) if len(re.findall(pattern, reply[\u0026#34;profile\u0026#34;])) == 0: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) replyList.pop(idx) else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;) #リプライする for reply in replyList: status = f\u0026#39;{reply[\u0026#34;name\u0026#34;]}さん、企画に参加ありがとうございます！\\nリプの御礼に{reply[\u0026#34;name\u0026#34;]}さんのツイートを最新から3件ほど、RTさせて頂きます♡\\n何回でも参加可能なので、またのご参加お待ちしております！\\n\\n※このツイートはbotからの自動送信です\u0026#39; in_reply_to_status_id = reply[\u0026#34;replyId\u0026#34;] print(f\u0026#34;in_reply_to_status_id:{in_reply_to_status_id} exec\u0026#34;) replyResponse = requests.post( f\u0026#39;https://api.twitter.com/1.1/statuses/update.json\u0026#39;, data={\u0026#34;status\u0026#34;:status ,\u0026#34;in_reply_to_status_id\u0026#34;:in_reply_to_status_id ,\u0026#34;auto_populate_reply_metadata\u0026#34;:True}, auth=getOauth() ).json() print(replyResponse) #リツイートする for idx in range(3): print(f\u0026#39;{reply[\u0026#34;tweetIdList\u0026#34;][idx]}をリツイート\u0026#39;) response = requests.post( f\u0026#39;https://api.twitter.com/1.1/statuses/retweet/{reply[\u0026#34;tweetIdList\u0026#34;][idx]}.json\u0026#39;, auth=getOauth() ).json() print(response) def lambda_handler(event, context): try: main() except: import traceback traceback.print_exc()   でーきーたーーー！！\n企画するのが楽しみ♡\n","description":"","id":22,"section":"posts","tags":["Python","twitter","aws"],"title":"自動リツイートする！そして完成！ twitterBot⑥","uri":"https://encr.jp/blog/posts/20200222_night/"},{"content":"前回の続き。\nそれぞれ実装していきます。\nもうね、もはや単純作業ww\n今はこんな感じ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  #自分宛のリプライを全て取得 response = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/mentions_timeline.json?count=10\u0026#39;, auth=getOauth() ).json() print(json.dumps(response, ensure_ascii=False, indent=4)) #その中から、指定した元ツイートに対してのリプライのみに絞り込む in_reply_to_status_id=1230223693969xxxxxx response = list(filter(lambda x:x[\u0026#34;in_reply_to_status_id\u0026#34;] == in_reply_to_status_id,response)) #自分のツイートを取得 doneList = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name={SCREEN_NAME}\u0026#39;, auth=getOauth() ).json() #元ツイートのidの一覧を取得 doneList = list(map(lambda x:x[\u0026#34;in_reply_to_status_id\u0026#34;],doneList)) print(json.dumps(doneList, ensure_ascii=False, indent=4)) #リプライする for r in response: in_reply_to_status_id=r[\u0026#34;id\u0026#34;] if in_reply_to_status_id not in doneList: status = f\u0026#39;{r[\u0026#34;user\u0026#34;][\u0026#34;name\u0026#34;]}さん、おはようございます！\\nリプありがとうございます♡\\n今日も頑張りましょうー！！\\n\\n※このツイートはbotからの自動送信です\u0026#39; print(f\u0026#34;in_reply_to_status_id:{in_reply_to_status_id} exec\u0026#34;) replyResponse = requests.post( f\u0026#39;https://api.twitter.com/1.1/statuses/update.json\u0026#39;, data={\u0026#34;status\u0026#34;:status ,\u0026#34;in_reply_to_status_id\u0026#34;:in_reply_to_status_id ,\u0026#34;auto_populate_reply_metadata\u0026#34;:True}, auth=getOauth() ).json() print(json.dumps(replyResponse, ensure_ascii=False, indent=4)) else: print(f\u0026#34;in_reply_to_status_id:{in_reply_to_status_id} skip\u0026#34;)   リプをくれた人の情報を確認 プロフィールを確認 statuses/mentions_timelineにプロフィールは含まれているはず。\n試してみる\n1 2 3 4 5 6  #自分宛のリプライを全て取得 response = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/mentions_timeline.json?count=10\u0026#39;, auth=getOauth() ).json() print(json.dumps(response, ensure_ascii=False, indent=4))   うん、入ってる。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  [ { \u0026#34;text\u0026#34;: \u0026#34;@engineergirl_w こんにちは！\u0026#34;, ～略～ \u0026#34;user\u0026#34;: { \u0026#34;id\u0026#34;: 1218002630783xxxxxx, \u0026#34;id_str\u0026#34;: \u0026#34;1218002630783xxxxxx\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;エンジョイクリエイト\u0026#34;, \u0026#34;screen_name\u0026#34;: \u0026#34;encrjp\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;linebot、webアプリ、iosアプリなどを開発しています。\u0026#34;, ～略～ } }, { ～略～ ]   リプをくれた人のidが[\u0026ldquo;user\u0026rdquo;][\u0026ldquo;id\u0026rdquo;]でプロフィールが[\u0026ldquo;user\u0026rdquo;][\u0026ldquo;description\u0026rdquo;]みたい。\nだから、[\u0026ldquo;user\u0026rdquo;][\u0026ldquo;description\u0026rdquo;]をチェックしていく。\n最近のツイートを確認 プロフィールだけでは分からないから、その人の最新のツイートを10件確認する。\n確認方法は、前回も使ったstatuses/user_timeline。\n1 2 3 4 5 6  id = 1218002630783xxxxxx doneList = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/user_timeline.json?id={id}\u0026#39;, auth=getOauth() ).json() print(json.dumps(doneList, ensure_ascii=False, indent=4))   1 2 3 4 5 6 7 8 9 10  [ { ～略～ \u0026#34;text\u0026#34;: \u0026#34;こんにちは！\u0026#34;, }, { ～略～ \u0026#34;text\u0026#34;: \u0026#34;テスト\u0026#34;, }, {   とれた。\nという事で、プロフィール=[\u0026ldquo;user\u0026rdquo;][\u0026ldquo;description\u0026rdquo;]と、最新のツイート[\u0026ldquo;text\u0026rdquo;]をチェックしていく。\nチェック エロ系 ここに入ってるワードと、個人的に気になるワードを設定。\nそれが含まれたらNGとする。\nちょっと汚くなっちゃったけど…。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  ngList=[\u0026#34;xxx\u0026#34;,\u0026#34;融資\u0026#34;,\u0026#34;裏垢\u0026#34;] replyList=[{\u0026#34;id\u0026#34;:1218002630783000000, \u0026#34;name\u0026#34;:\u0026#34;twitter花子\u0026#34;, \u0026#34;profile\u0026#34;:\u0026#34;twitter花子です。裏垢女子です\u0026#34;, \u0026#34;tweetList\u0026#34;:[\u0026#34;花子だよ。おはよう\u0026#34;, \u0026#34;花子だよ。こんにちは\u0026#34;] } ,{\u0026#34;id\u0026#34;:1218002630783000000, \u0026#34;name\u0026#34;:\u0026#34;twitter太郎\u0026#34;, \u0026#34;profile\u0026#34;:\u0026#34;twitter太郎です。金持ちだよ\u0026#34;, \u0026#34;tweetList\u0026#34;:[\u0026#34;太郎だよ。おはよう。融資するよ\u0026#34;, \u0026#34;太郎だよ。こんにちは\u0026#34;] } ,{\u0026#34;id\u0026#34;:1218002630783000000, \u0026#34;name\u0026#34;:\u0026#34;twitter次郎\u0026#34;, \u0026#34;profile\u0026#34;:\u0026#34;twitter次郎です。ブロガーです\u0026#34;, \u0026#34;tweetList\u0026#34;:[\u0026#34;次郎だよ。おはよう\u0026#34;, \u0026#34;次郎だよ。こんにちは\u0026#34;] } ] #NGワードチェック for reply in replyList: #プロフィールをチェック if len(list(filter(lambda ng:ng in reply[\u0026#34;profile\u0026#34;],ngList))): print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) #ツイートをチェック elif len(list(filter(lambda x:len(list(filter(lambda ng:ng in x,ngList))),reply[\u0026#34;tweetList\u0026#34;]))): print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;)   結果\ntwitter花子:ng twitter太郎:ng twitter次郎:ok こんな感じでフィルターかかります。\n怪しい勧誘系 エロ系と同じ感じで進めていく。\n1ツイート内に、複数のリンクがあったらNG 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  replyList=[{\u0026#34;id\u0026#34;:1218002630783000000, \u0026#34;name\u0026#34;:\u0026#34;twitter花子\u0026#34;, \u0026#34;profile\u0026#34;:\u0026#34;twitter花子です。裏垢女子です\u0026#34;, \u0026#34;tweetList\u0026#34;:[\u0026#34;花子だよ。おはよう。クリックしてね♡　http://xxxx https://xxxx\u0026#34;, \u0026#34;花子だよ。こんにちは\u0026#34;] } ,{\u0026#34;id\u0026#34;:1218002630783000000, \u0026#34;name\u0026#34;:\u0026#34;twitter太郎\u0026#34;, \u0026#34;profile\u0026#34;:\u0026#34;twitter太郎です。金持ちだよ\u0026#34;, \u0026#34;tweetList\u0026#34;:[\u0026#34;太郎だよ。おはよう。融資するよ。クリックしてね♡　http://xxxx \u0026#34;, \u0026#34;太郎だよ。こんにちは\u0026#34;] } ,{\u0026#34;id\u0026#34;:1218002630783000000, \u0026#34;name\u0026#34;:\u0026#34;twitter次郎\u0026#34;, \u0026#34;profile\u0026#34;:\u0026#34;twitter次郎です。ブロガーです\u0026#34;, \u0026#34;tweetList\u0026#34;:[\u0026#34;次郎だよ。おはよう\u0026#34;, \u0026#34;次郎だよ。こんにちは\u0026#34;] } ] #リンク数チェック for reply in replyList: #ツイートをチェック if len(list(filter(lambda x:x.count(\u0026#34;http\u0026#34;)\u0026gt;=2,reply[\u0026#34;tweetList\u0026#34;]))): print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;)   結果\ntwitter花子:ng twitter太郎:ok twitter次郎:ok うん、いい感じ。\n10ツイート通して、同じリンクが3つ以上あったらNG う、ちょっとめんどくさくなってきた…。\nなんか、練習問題みたい…\nちょっと、無理やり色々やってしまったから、コメントとprint多めにしておきましたw\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  replyList=[{\u0026#34;id\u0026#34;:1218002630783000000, \u0026#34;name\u0026#34;:\u0026#34;twitter花子\u0026#34;, \u0026#34;profile\u0026#34;:\u0026#34;twitter花子です。裏垢女子です\u0026#34;, \u0026#34;tweetList\u0026#34;:[\u0026#34;花子だよ。おはよう。クリックしてね♡　http://xxxx1\u0026#34;, \u0026#34;花子だよ。こんにちは。クリックしてね♡　http://xxxx1\u0026#34;, \u0026#34;花子だよ。おやすみ。クリックしてね♡　http://xxxx1\u0026#34;, \u0026#34;花子だよ。おはよう。クリックしてね♡\u0026#34;] } ,{\u0026#34;id\u0026#34;:1218002630783000000, \u0026#34;name\u0026#34;:\u0026#34;twitter太郎\u0026#34;, \u0026#34;profile\u0026#34;:\u0026#34;twitter太郎です。金持ちだよ\u0026#34;, \u0026#34;tweetList\u0026#34;:[\u0026#34;太郎だよ。おはよう。融資するよ。クリックしてね　http://xxxx1 \u0026#34;, \u0026#34;太郎だよ。こんにちは。クリックしてね　http://xxxx1\u0026#34;, \u0026#34;太郎だよ。こんにちは。クリックしてね　http://xxxx2\u0026#34;] } ] pattern = \u0026#34;https?://[\\w/:%#\\$\u0026amp;\\?\\(\\)~\\.=\\+\\-]+\u0026#34; #リンク数チェック for reply in replyList: #urlを抽出 ※既に1ツイート内に複数urlある場合は除外しているので、ここに来た時には、必ず1ツイート0～1url #まずurlを含むものだけに絞る urlTweetList =list(filter(lambda x:x.count(\u0026#34;http\u0026#34;)==1,reply[\u0026#34;tweetList\u0026#34;])) print(f\u0026#34;urlTweetList:{urlTweetList}\u0026#34;) #urlを抽出 urlList = list(map(lambda x:re.findall(pattern, x)[0],urlTweetList)) print(f\u0026#34;urlList:{urlList}\u0026#34;) #urlListのそれぞれのurlの出現回数をカウントしてくれる ※要import collections counter = collections.Counter(urlList) print(f\u0026#34;counter:{counter}\u0026#34;) if len(list(filter(lambda x:x \u0026gt;= 3,counter.values()))): print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;)   結果\n$ python test.py tweetList:['花子だよ。おはよう。クリックしてね♡\\u3000http://xxxx1', '花子だよ。こんにちは。クリックしてね♡\\u3000http://xxxx1', '花子だよ。おやすみ。クリックしてね♡\\u3000http://xxxx1'] urlList:['http://xxxx1', 'http://xxxx1', 'http://xxxx1'] counter:Counter({'http://xxxx1': 3}) twitter花子:ng tweetList:['太郎だよ。おはよう。融資するよ。クリックしてね\\u3000http://xxxx1 ', '太郎だよ。こんにちは。クリックしてね\\u3000http://xxxx1', '太郎だよ。こんにちは。クリックしてね\\u3000http://xxxx2'] urlList:['http://xxxx1', 'http://xxxx1', 'http://xxxx2'] counter:Counter({'http://xxxx1': 2, 'http://xxxx2': 1}) twitter太郎:ok 10ツイート中、リツイート企画みたいな内容のツイートが3つ以上あったらNG ↑と、NGワードのとほぼ同じ感じで\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  replyList=[{\u0026#34;id\u0026#34;:1218002630783000000, \u0026#34;name\u0026#34;:\u0026#34;twitter花子\u0026#34;, \u0026#34;profile\u0026#34;:\u0026#34;twitter花子です。裏垢女子です\u0026#34;, \u0026#34;tweetList\u0026#34;:[\u0026#34;花子だよ。おはよう。クリックしてね♡　#RT企画 http://xxxx1\u0026#34;, \u0026#34;花子だよ。こんにちは。クリックしてね♡ 固ツイリツイートするよ！　http://xxxx1\u0026#34;, \u0026#34;花子だよ。おやすみ。クリックしてね♡　#RT企画　http://xxxx1\u0026#34;, \u0026#34;花子だよ。おはよう。クリックしてね♡\u0026#34;] } ,{\u0026#34;id\u0026#34;:1218002630783000000, \u0026#34;name\u0026#34;:\u0026#34;twitter太郎\u0026#34;, \u0026#34;profile\u0026#34;:\u0026#34;twitter太郎です。金持ちだよ\u0026#34;, \u0026#34;tweetList\u0026#34;:[\u0026#34;太郎だよ。おはよう。融資するよ。クリックしてね　http://xxxx1 \u0026#34;, \u0026#34;太郎だよ。こんにちは。クリックしてね　#RT企画　http://xxxx1\u0026#34;, \u0026#34;太郎だよ。こんにちは。クリックしてね　http://xxxx2\u0026#34;] } ] warnList = [\u0026#34;RT企画\u0026#34;,\u0026#34;固定ツイート\u0026#34;,\u0026#34;固ツイ\u0026#34;,\u0026#34;リツイート\u0026#34;] #RT企画数チェック for reply in replyList: if len(list(filter(lambda x:len(list(filter(lambda warn:warn in x,warnList))),reply[\u0026#34;tweetList\u0026#34;]))) \u0026gt;= 3: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;)   結果\n$ python test.py twitter花子:ng twitter太郎:ok 日本語じゃない系 ふぅ。\n最後。\nこれは簡単。プロフィールに日本語が含まれてなかったらNG\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  replyList=[{\u0026#34;id\u0026#34;:1218002630783000000, \u0026#34;name\u0026#34;:\u0026#34;twitter花子\u0026#34;, \u0026#34;profile\u0026#34;:\u0026#34;twitter花子です。裏垢女子です\u0026#34;, \u0026#34;tweetList\u0026#34;:[\u0026#34;花子だよ。おはよう。クリックしてね♡　#RT企画 http://xxxx1\u0026#34;] } ,{\u0026#34;id\u0026#34;:1218002630783000000, \u0026#34;name\u0026#34;:\u0026#34;twitter太郎\u0026#34;, \u0026#34;profile\u0026#34;:\u0026#34;my name is twitter taro!!\u0026#34;, \u0026#34;tweetList\u0026#34;:[\u0026#34;太郎だよ。おはよう。融資するよ。クリックしてね　http://xxxx1 \u0026#34;] } ] #日本語チェック pattern = \u0026#34;[\\u3041-\\u309F]+\u0026#34; #ひらがな for reply in replyList: print(re.findall(pattern, reply[\u0026#34;profile\u0026#34;])) if len(re.findall(pattern, reply[\u0026#34;profile\u0026#34;])) == 0: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;)   結果\n['です', 'です'] twitter花子:ok [] twitter太郎:ng くっつける ふぅ。できた。\n疲れた…。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140  from requests_oauthlib import OAuth1Session, OAuth1 import requests import json import codecs import time import os import datetime import collections import re OAUTH1 = os.environ[\u0026#39;OAUTH1\u0026#39;] OAUTH2 = os.environ[\u0026#39;OAUTH2\u0026#39;] OAUTH3 = os.environ[\u0026#39;OAUTH3\u0026#39;] OAUTH4 = os.environ[\u0026#39;OAUTH4\u0026#39;] SCREEN_NAME = os.environ[\u0026#39;SCREEN_NAME\u0026#39;] def getOauth(): return OAuth1(OAUTH1, OAUTH2, OAUTH3, OAUTH4) def main(): #自分宛のリプライ最新から10件を全て取得 response = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/mentions_timeline.json?count=10\u0026#39;, auth=getOauth() ).json() #その中から、指定した元ツイートに対してのリプライのみに絞り込む in_reply_to_status_id=1231087256556000000 response = list(filter(lambda x:x[\u0026#34;in_reply_to_status_id\u0026#34;] == in_reply_to_status_id,response)) #未リプライの物のみに絞り込む doneList = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name={SCREEN_NAME}\u0026#39;, auth=getOauth() ).json() doneList = list(map(lambda x:x[\u0026#34;in_reply_to_status_id\u0026#34;],doneList)) print(json.dumps(doneList, ensure_ascii=False, indent=4)) response = list(filter(lambda x:x[\u0026#34;id\u0026#34;] not in doneList,response)) print(json.dumps(response, ensure_ascii=False, indent=4)) #扱いやすいように成型 replyList = list(map(lambda x:{\u0026#34;id\u0026#34;:x[\u0026#34;user\u0026#34;][\u0026#34;id\u0026#34;],\u0026#34;name\u0026#34;:x[\u0026#34;user\u0026#34;][\u0026#34;name\u0026#34;],\u0026#34;profile\u0026#34;:x[\u0026#34;user\u0026#34;][\u0026#34;description\u0026#34;]},response)) print(json.dumps(replyList, ensure_ascii=False, indent=4)) for idx,r in enumerate(replyList): user_timeline = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/user_timeline.json?id={r[\u0026#34;id\u0026#34;]}\u0026amp;count=10\u0026#39;, auth=getOauth() ).json() replyList[idx][\u0026#34;tweetList\u0026#34;] = list(map(lambda x:x[\u0026#34;text\u0026#34;],user_timeline)) print(json.dumps(replyList, ensure_ascii=False, indent=4)) #NGワードチェック print(\u0026#34;NGワードチェック\u0026#34;) ngList=[\u0026#34;xxx\u0026#34;,\u0026#34;融資\u0026#34;,\u0026#34;裏垢\u0026#34;] for idx,reply in enumerate(replyList): #プロフィールをチェック if len(list(filter(lambda ng:ng in reply[\u0026#34;profile\u0026#34;],ngList))) or \\ len(list(filter(lambda x:len(list(filter(lambda ng:ng in x,ngList))),reply[\u0026#34;tweetList\u0026#34;]))): print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) replyList.pop(idx) else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;) #リンク数チェック print(\u0026#34;リンク数チェック\u0026#34;) for idx,reply in enumerate(replyList): #ツイートをチェック if len(list(filter(lambda x:x.count(\u0026#34;http\u0026#34;)\u0026gt;=2,reply[\u0026#34;tweetList\u0026#34;]))): print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) #replyList.pop(idx) else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;) #重複リンク数チェック print(\u0026#34;重複リンク数チェック\u0026#34;) pattern = \u0026#34;https?://[\\w/:%#\\$\u0026amp;\\?\\(\\)~\\.=\\+\\-]+\u0026#34; for idx,reply in enumerate(replyList): #urlを抽出 ※既に1ツイート内に複数urlある場合は除外しているので、ここに来た時には、必ず1ツイート0～1url #まずurlを含むものだけに絞る urlTweetList =list(filter(lambda x:x.count(\u0026#34;http\u0026#34;)==1,reply[\u0026#34;tweetList\u0026#34;])) print(f\u0026#34;urlTweetList:{urlTweetList}\u0026#34;) #urlを抽出 urlList = list(map(lambda x:re.findall(pattern, x)[0],urlTweetList)) print(f\u0026#34;urlList:{urlList}\u0026#34;) #urlListのそれぞれのurlの出現回数をカウントしてくれる ※要import collections counter = collections.Counter(urlList) print(f\u0026#34;counter:{counter}\u0026#34;) if len(list(filter(lambda x:x \u0026gt;= 3,counter.values()))): print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) replyList.pop(idx) else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;) warnList = [\u0026#34;RT企画\u0026#34;,\u0026#34;固定ツイート\u0026#34;,\u0026#34;固ツイ\u0026#34;,\u0026#34;リツイート\u0026#34;] #RT企画数チェック print(\u0026#34;RT企画数チェック\u0026#34;) for idx,reply in enumerate(replyList): if len(list(filter(lambda x:len(list(filter(lambda warn:warn in x,warnList))),reply[\u0026#34;tweetList\u0026#34;]))) \u0026gt;= 3: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) replyList.pop(idx) else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;) #日本語チェック print(\u0026#34;日本語チェック\u0026#34;) pattern = \u0026#34;[\\u3041-\\u309F]+\u0026#34; #ひらがな for idx,reply in enumerate(replyList): print(re.findall(pattern, reply[\u0026#34;profile\u0026#34;])) if len(re.findall(pattern, reply[\u0026#34;profile\u0026#34;])) == 0: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ng\u0026#34;) replyList.pop(idx) else: print(f\u0026#34;{reply[\u0026#39;name\u0026#39;]}:ok\u0026#34;) #リプライする for r in response: status = f\u0026#39;{r[\u0026#34;user\u0026#34;][\u0026#34;name\u0026#34;]}さん、企画に参加ありがとうございます！\\nリプの御礼に{r[\u0026#34;user\u0026#34;][\u0026#34;name\u0026#34;]}さんのツイートを3件ほど、リツイートさせて頂きます♡\\n\\n※このツイートはbotからの自動送信です\u0026#39; in_reply_to_status_id=r[\u0026#34;id\u0026#34;] print(f\u0026#34;in_reply_to_status_id:{in_reply_to_status_id} exec\u0026#34;) replyResponse = requests.post( f\u0026#39;https://api.twitter.com/1.1/statuses/update.json\u0026#39;, data={\u0026#34;status\u0026#34;:status ,\u0026#34;in_reply_to_status_id\u0026#34;:in_reply_to_status_id ,\u0026#34;auto_populate_reply_metadata\u0026#34;:True}, auth=getOauth() ).json() print(json.dumps(replyResponse, ensure_ascii=False, indent=4)) def lambda_handler(event, context): try: main() except: import traceback traceback.print_exc()   独り言 ふぅ。疲れた…。\nあとは、リツイートするだけ。\nでもそろそろフォロワー5000人行ってしまいそう…。\n間に合うかな…。\n少し休憩したら続き頑張ろう…。\n","description":"","id":23,"section":"posts","tags":["Python","twitter","aws"],"title":"変なアカウントをブロックする[実装編] twitterBot⑤","uri":"https://encr.jp/blog/posts/20200222_lunch/"},{"content":"前回の続き。\nリプをくれた人に対して御礼をするっていう企画用のbotを進めていきます。\nリプをくれた人のプロフィールを確認 リプをくれた人に御礼のリツイートをするっていう企画なんだけど、変なアカウントの拡散はしたくない。\nエロ系、怪しい勧誘系、あと日本語じゃない系\n独断と偏見でフィルターかけていきます。\nまずは定義というか、どうフィルター書けるかを決めていきます。\nエロ系 グーグルクロール様にインデックス登録されそうだから、ブログに直では書かないんだけども、ありがちなワードを禁止リストに設定していく。\nあ、いや、検索してみようかな？\nう…違う…\nこっちだねww\nで、このへんとか見ていく。\nうーん。なんか違う気もするけど…。\nとりあえずこの辺の文字を過去10ツイート＆プロフィールに入れてなければ、エロ垢ではないとみなしてあげましょうかね？\n怪しい勧誘系 これがね。難しい！\nほんとにね、AIが必要ですわよ。\nなんちゃらビジネスで年収1000万円！とかいうやつね。\n真面目に頑張ってるブロガーさんならお金の話してようが、宣伝だろうが広告だろうがブロックしたくないけど、嘘ばっかりの勧誘ならブロックしたい…\nので！\n独断と偏見で、頑張ってるか、頑張ってないか。で判断することにした！\n過去10ツイートをさかのぼって、\n①1ツイート内に、複数のリンクがあったらNG\n②10ツイート通して、同じリンクが3つ以上あったらNG\n頑張ってるブロガーさんは、同じリンクを何度も貼らないでしょう？という偏見www\n③10ツイート中、リツイート企画みたいな内容のツイートが3つ以上あったらNG\nあと、これは完全な私の好みですが、リツイート企画ばっかりやっている人も好きでないので…。\nとりあえず、このくらいの緩さで初めてみる。\nやりながら条件厳しくしたりしていこう！\n日本語じゃない系 これは簡単プロフィールに日本語が含まれてなかったらNG\n独り言 よし、朝活終わり！\n三日坊主の私が、かれこれなんと11日目ですよ。\n11日目で、これが26記事目です。\n我ながら、よく頑張ってると思うww\nここまで続けられたらね。このまま1年位は頑張りたい！\n1年間。毎日2記事上げていったら700記事かー\nうん、頑張ろう！整体行ってきます//\n","description":"","id":24,"section":"posts","tags":["Python","twitter","aws"],"title":"変なアカウントをブロックする twitterBot④","uri":"https://encr.jp/blog/posts/20200222_morning/"},{"content":"イベントでLTしてきました。\n ちなみにショートコードのうめこみはこちらを参考にさせて頂きました！\n余裕があったら、記事にします！\n今日はこれだけww\n","description":"","id":25,"section":"posts","tags":["aws","hugo","aws"],"title":"lineBot作ったら売れた話","uri":"https://encr.jp/blog/posts/20200221_night/"},{"content":"やばい！今日の夜のイベントのLT資料終わってない！\nアーキテクチャ図、速攻で作らないと💦\nいつもブログでは、mdで書けるアーキ図使ってるんだけど、パワポだからね。\nちゃんと書こう。\nツールを探す AWS 公式アイコンセット\nなんか色々あるみたい。\n立体より平面が好きなのと、簡単そうなので、draw.ioを選択。\ndraw.io\ndraw.io なんか、色々使いこなせてない感はあるけど、時間ないからもうこんな感じでいいや\nサービス引っ張ってきて、線引いただけ。\nサービス名書いているのと書いてないのある…\n今度余裕あるときに直そう。\n完成したら、save asでローカルにdrawioファイルが保存できる。\nこれを持っておけば、続きから編集とかできるみたい。\n出力はExport asでpngとかに出力できる。\n完成 完成したのはこちら\nうーん、お昼は短いねぇ。\nイベント向かう電車の中で仕上げしましょうかねww\n","description":"","id":26,"section":"posts","tags":["aws","draw.io"],"title":"パワポ資料用にアーキテクチャ図書く draw.io","uri":"https://encr.jp/blog/posts/20200221_lunch/"},{"content":"昼の記事の続き！\nなぜか自分にはリプライできるのに、他人にはリプライできない問題…。\n色々検索したんだけど、有益な情報が見つからず…。\n公式ドキュメント 初心に戻って公式リファレンスをよく読むことに。\n公式リファレンス\n公式リファレンスのin_reply_to_status_idの欄。\n The ID of an existing status that the update is in reply to. Note: This parameter will be ignored unless the author of the Tweet this parameter references is mentioned within the status text. Therefore, you must include @username , where username is the author of the referenced Tweet, within the update.\n 注目すべきはこのNoteの部分。\n要約すると、\nin_reply_to_status_idを使う場合は、必ずアテンション(@ユーザー名)をツイート内容に含んでくださいね。\nつけないと、in_reply_to_status_idは無視されますよ。\nとのこと…。\n自分へのリプライの時はアテンションなくても追加のツイートみたいな扱いでつぶやけてただけっぽい。\n全く…。\n無駄な時間を過ごしたぜ…。\nアテンションをつける で、アテンションつけようかと思ったんだけど、つけなくても、アテンションの代わりに、auto_populate_reply_metadataってやつをtrueにすればいいみたい。\n If set to true and used with in_reply_to_status_id, leading @mentions will be looked up from the original Tweet, and added to the new Tweet from there. This wil append @mentions into the metadata of an extended Tweet as a reply chain grows, until the limit on @mentions is reached. In cases where the original Tweet has been deleted, the reply will fail.\n で、やってみる。\n1 2 3 4 5 6 7 8 9 10 11  status = f\u0026#39;おはようございます！\\n※このツイートはbotからの自動送信です\u0026#39; in_reply_to_status_id = 1230251616160xxxxxx print(f\u0026#34;in_reply_to_status_id:{in_reply_to_status_id}\u0026#34;) response = requests.post( f\u0026#39;https://api.twitter.com/1.1/statuses/update.json\u0026#39;, data={\u0026#34;status\u0026#34;:status ,\u0026#34;in_reply_to_status_id\u0026#34;:in_reply_to_status_id ,\u0026#34;auto_populate_reply_metadata\u0026#34;:True}, auth=getOauth() ).json() print(json.dumps(response, ensure_ascii=False, indent=4))   結果は…\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  { \u0026#34;created_at\u0026#34;: \u0026#34;Wed Feb 19 22:37:16 +0000 2020\u0026#34;, \u0026#34;id\u0026#34;: 1230260085839xxxxxx, \u0026#34;id_str\u0026#34;: \u0026#34;1230260085839xxxxxx\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;@xxxxx おはようございます！\\n※このツイートはbotからの自動送信です\u0026#34;, ～略～ { \u0026#34;screen_name\u0026#34;: \u0026#34;xxxx\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;xxxxx\u0026#34;, \u0026#34;id\u0026#34;: 1218002630783xxxxxx, \u0026#34;id_str\u0026#34;: \u0026#34;1218002630783xxxxxx\u0026#34;, } }, \u0026#34;in_reply_to_status_id\u0026#34;: 1230251616160xxxxxx, ～略～   入ったーーー！\nメンションも勝手に入ったし、in_reply_to_status_idも設定された！\nよし、次\nリプライ済のものは無視する これが結構大変そう…。\n自分のツイート取ってきて、リプライしてるかどうか確認しましょうかね？\n最初の方にも使ったこれ。\n1 2 3 4  response = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name={SCREEN_NAME}\u0026#39;, auth=getOauth() ).json()   で、取ってきた中身から、リプライ元のidを取得\nlistの中のdictの中のin_reply_to_status_idを取ってくる\n1 2 3 4 5  response = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name={SCREEN_NAME}\u0026#39;, auth=getOauth() ).json() response = list(map(lambda x:x[\u0026#34;in_reply_to_status_id\u0026#34;],response))   [ 1230251616160xxxxxx, null, null, 1230232810620xxxxxx, null, 1230232810620xxxxxx, 1230234142802xxxxxx, ～略～ リプライ対象がここに含まれてたら無視ってしましょうかね。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  #自分宛のリプライを全て取得 response = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/mentions_timeline.json?count=10\u0026#39;, auth=getOauth() ).json() print(json.dumps(response, ensure_ascii=False, indent=4)) #その中から、指定した元ツイートに対してのリプライのみに絞り込む response = list(filter(lambda x:x[\u0026#34;in_reply_to_status_id\u0026#34;] == in_reply_to_status_id,response)) #自分のツイートを取得 in_reply_to_status_id=1230223693969xxxxxx doneList = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name={SCREEN_NAME}\u0026#39;, auth=getOauth() ).json() #元ツイートのidの一覧を取得 doneList = list(map(lambda x:x[\u0026#34;in_reply_to_status_id\u0026#34;],doneList)) print(json.dumps(doneList, ensure_ascii=False, indent=4)) #リプライする for r in response: in_reply_to_status_id=r[\u0026#34;id\u0026#34;] if in_reply_to_status_id not in doneList: status = f\u0026#39;{r[\u0026#34;user\u0026#34;][\u0026#34;name\u0026#34;]}さん、おはようございます！\\nリプありがとうございます♡\\n今日も頑張りましょうー！！\\n\\n※このツイートはbotからの自動送信です\u0026#39; print(f\u0026#34;in_reply_to_status_id:{in_reply_to_status_id} exec\u0026#34;) replyResponse = requests.post( f\u0026#39;https://api.twitter.com/1.1/statuses/update.json\u0026#39;, data={\u0026#34;status\u0026#34;:status ,\u0026#34;in_reply_to_status_id\u0026#34;:in_reply_to_status_id ,\u0026#34;auto_populate_reply_metadata\u0026#34;:True}, auth=getOauth() ).json() print(json.dumps(replyResponse, ensure_ascii=False, indent=4)) else: print(f\u0026#34;in_reply_to_status_id:{in_reply_to_status_id} skip\u0026#34;)   できた！\nevent設定 最後にcloudWatchイベントを追加して…\n完成！\n","description":"","id":27,"section":"posts","tags":["Python","twitter","aws"],"title":"特定のリプに自動リプライする twitterBot③","uri":"https://encr.jp/blog/posts/20200220_night/"},{"content":"朝、とりあえず適当な自分のツイートにリプライするまでできた。\nでも自動リプライしたいのはこれじゃないんだよね…。\n今回は、本命のツイートにリプライするまで！\n指定ツイートのリプライのstatus_idを取得 users/show.jsonでは、最新の1ツイートしか取得できないから、他の方法で、前のツイートまで取得する！\n指定ツイートのstatus_idを取得 https://syncer.jp/Web/API/Twitter/REST_API/GET/statuses/user_timeline/\nhttps://api.twitter.com/1.1/statuses/user_timeline.json\nこのへんでとれるかな…？\n1 2 3 4 5 6 7 8 9  def main(): response = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/user_timeline.json?screen_name={SCREEN_NAME}\u0026#39;, auth=getOauth() ).json() print(json.dumps(response, ensure_ascii=False, indent=4))   うん、取れた\nさっきのstatusの中身が配列でかえってくるっぼい。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  [ { \u0026#34;created_at\u0026#34;: \u0026#34;Wed Feb 19 21:12:03 +0000 2020\u0026#34;, \u0026#34;id\u0026#34;: 1230238643068xxxxxx, \u0026#34;id_str\u0026#34;: \u0026#34;1230238643068xxxxxx\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;test \\n ※このツイートはbotからの自動ツイートです\u0026#34;, \u0026#34;truncated\u0026#34;: false, }, { \u0026#34;created_at\u0026#34;: \u0026#34;Wed Feb 19 20:54:10 +0000 2020\u0026#34;, \u0026#34;id\u0026#34;: 1230234142802xxxxxx, \u0026#34;id_str\u0026#34;: \u0026#34;1230234142802xxxxxx\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;test \\n ※このツイートはbotからの自動ツイートです\u0026#34;, \u0026#34;truncated\u0026#34;: false, }, { \u0026#34;created_at\u0026#34;: \u0026#34;Wed Feb 19 20:48:53 +0000 2020\u0026#34;, \u0026#34;id\u0026#34;: 1230232810620xxxxxx, \u0026#34;id_str\u0026#34;: \u0026#34;1230232810620xxxxxx\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;テスト\u0026#34;, }, ～略～   指定ツイートのリプライのstatus_idを取得 で、私がしたかったのは、私のツイートに対してのリプライに対しての、リプライwww\nなので、指定ツイートのリプライのstatus_idを取得する。\nGET statuses/show/:id - ツイートを個別に取得する\nこの辺かなー？\nhttps://api.twitter.com/1.1/statuses/show.json\n1 2 3 4  response = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/show.json?id=1230223693969707008\u0026#39;, auth=getOauth() ).json()   だめだな\nさっきのstatusの中身が返ってくるだけだ。\nこっちか？\nGET statuses/mentions_timeline - メンションタイムラインを取得する\nhttps://api.twitter.com/1.1/statuses/mentions_timeline.json\n1 2 3 4  response = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/mentions_timeline.json?count=20\u0026#39;, auth=getOauth() ).json()   きた！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  [ { ～略～ \u0026#34;id\u0026#34;: 1230233631869xxxxxx, \u0026#34;id_str\u0026#34;: \u0026#34;1230233631869xxxxxx\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;@xx おはようございます\u0026#34;, ～略～ \u0026#34;user\u0026#34;: { ～略～ \u0026#34;name\u0026#34;: \u0026#34;twitter太郎\u0026#34;, \u0026#34;screen_name\u0026#34;: \u0026#34;twitter111\u0026#34;, ～略～ }, ～略～ }, { ～略～ \u0026#34;id\u0026#34;: 1230233631869xxxxxx, \u0026#34;id_str\u0026#34;: \u0026#34;1230233631869xxxxxx\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;@xx おはようございます\u0026#34;, ～略～ \u0026#34;user\u0026#34;: { ～略～ ～略～   対象ツイート向けのリプライのみにfillter でも、自分宛のリプライが問答無用で取得されるみたい。\nだから、ここで取得したリストから、対象のツイートへのリプライだけに絞り込まないといけない\nそしてどうやら自分あてのリプライは取得できないようだ…\nしょうがない。テスト用にサブ垢からリプライしておくか…。\nどのツイートに対してのリプライかは、in_reply_to_status_idで分かるみたいなので、in_reply_to_status_idが対象なもので絞る\n1 2 3 4 5 6  in_reply_to_status_id=1230223693969707008 response = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/mentions_timeline.json?count=20\u0026#39;, auth=getOauth() ).json() response = list(filter(lambda x:x[\u0026#34;in_reply_to_status_id\u0026#34;] == in_reply_to_status_id,response))   リプライメッセージを作成 ○○さん、おはようございます！ ※このツイートはbotからの自動送信です とりあえず、こんなところだろうか？\n名前はさっきのresponseのuserのnameから取得できそうなので、やってみる。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  #自分宛のリプライを全て取得 response = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/mentions_timeline.json?count=20\u0026#39;, auth=getOauth() ).json() #その中から、指定した元ツイートに対してのリプライのみに絞り込む in_reply_to_status_id=1230223693969xxxxxx response = list(filter(lambda x:x[\u0026#34;in_reply_to_status_id\u0026#34;] == in_reply_to_status_id,response)) #一件ずつ、リプライメッセージを作成していく for r in response: message = f\u0026#39;{r[\u0026#34;user\u0026#34;][\u0026#34;name\u0026#34;]}さん、おはようございます！\\n※このツイートはbotからの自動送信です\u0026#39; print(f\u0026#39;replyMessage:{message}\u0026#39;)   replyMessage:twitter太郎さん、おはようございます！ ※このツイートはbotからの自動送信です replyMessage:twitter花子さん、おはようございます！ ※このツイートはbotからの自動送信です うん、よさげ。\nリプライする。 今までのを組み合わせる。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  #自分宛のリプライを全て取得 response = requests.get( f\u0026#39;https://api.twitter.com/1.1/statuses/mentions_timeline.json?count=20\u0026#39;, auth=getOauth() ).json() #その中から、指定した元ツイートに対してのリプライのみに絞り込む in_reply_to_status_id=1230223693969xxxxxx response = list(filter(lambda x:x[\u0026#34;in_reply_to_status_id\u0026#34;] == in_reply_to_status_id,response)) #リプライする for r in response: status = f\u0026#39;{r[\u0026#34;user\u0026#34;][\u0026#34;name\u0026#34;]}さん、おはようございます！\\n※このツイートはbotからの自動送信です\u0026#39; in_reply_to_status_id=r[\u0026#34;id\u0026#34;] response = requests.post( f\u0026#39;https://api.twitter.com/1.1/statuses/update.json\u0026#39;, data={\u0026#34;status\u0026#34;:status,\u0026#34;in_reply_to_status_id\u0026#34;:in_reply_to_status_id}, auth=getOauth() ).json()   { ～略～ \u0026quot;text\u0026quot;: \u0026quot;xxxxさん、おはようございます\\n※このツイートはbotからの自動送信です\u0026quot;, ～略～ \u0026quot;in_reply_to_status_id\u0026quot;: null, \u0026quot;in_reply_to_status_id_str\u0026quot;: null, \u0026quot;in_reply_to_user_id\u0026quot;: null, \u0026quot;in_reply_to_user_id_str\u0026quot;: null, \u0026quot;in_reply_to_screen_name\u0026quot;: null, \u0026quot;user\u0026quot;: { え？\nどうして？\nリプライが出来ない…。\nなんどやっても、ただのツイートになってしまう…。\nリプライが上手くいくと、in_reply_to_status_idに元ツイートのidが入るはず…。\n試しに、朝の記事のidで試すと上手くリプライできる。\nなんで？権限？\n自分へのリプライはできるけど、他人へのリプライはできないってこと…！？\nググったり、公式ドキュメントを読んだり…。\nここで1時間くらいかかった…。\nつらい戦いだった…。\n解決編は、また夜に。\n","description":"","id":28,"section":"posts","tags":["Python","twitter"],"title":"twitter apiで特定ツイートの情報を取得 twitterBot②","uri":"https://encr.jp/blog/posts/20200220_lunch/"},{"content":"今日は自動リプライbot作ります！\n本当はwebhookで拾って、リプライするのがいいんだけど、さくっと作りたいので、10分起きに特定のツイート覗きに行って、そのツイートに新しいリプがついてたら、それにリプするって形で作ってみます。\nなかなかの文量になりそうで、まとめるの時間かかりそうなので、3本立てくらいでお送りしますww\nツイートしてみる まずは、ツイートしてみます！\n下準備 awsのlambdaで作ります。cloudWatchEventで10分起きに起動！\nうーん、お手軽ww\ntwitterApiはoauthっていう認証が必要なのと、request入ってる方が便利なので、その辺をlayersに固めていきます。\n今日はお手軽にdockerは使いません！使わなくてもいけるライブラリー達！\nmkdir layer/python cd layer/python pip install -t . requests pip install -t . requests_oauthlib で、cloudformationでデプロイします。\n初めての方…。\n説明なくてすみません。\n基本的に作業記録なもので…。\nリクエストあれば、今度別記事で、もっと詳細書きます！\ntmplate.yamlはこんな感じ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  AWSTemplateFormatVersion:\u0026#39;2010-09-09\u0026#39;Transform:\u0026#39;AWS::Serverless-2016-10-31\u0026#39;Description:apigw,lambda,layersandsqsParameters:Oauth1:Type:StringOauth2:Type:StringOauth3:Type:StringOauth4:Type:StringScreenName:Type:StringResources:twitterAutoReply:Type:\u0026#39;AWS::Serverless::Function\u0026#39;Properties:FunctionName:\u0026#39;twitter-auto-reply\u0026#39;Handler:lambda_function.lambda_handlerRuntime:python3.7CodeUri:src/twitterAutoReplyDescription:\u0026#39;twitter-auto-reply\u0026#39;Environment:Variables:OAUTH1:!Sub${Oauth1}OAUTH2:!Sub${Oauth2}OAUTH3:!Sub${Oauth3}OAUTH4:!Sub${Oauth4}SCREEN_NAME:!Sub${ScreenName}MemorySize:512Timeout:60Role:!Sub\u0026#39;arn:aws:iam::${AWS::AccountId}:role/service-role/slackBotRole\u0026#39;Tags:Env:devproject:twitterBotLayers:- !RefTwitterModulesLayerTwitterModulesLayer:Type:AWS::Serverless::LayerVersionProperties:Description:TwitterModulesLayerContentUri:./src/layerCompatibleRuntimes:- python3.7- python3.6  メインソース で、メインのソースはとりあえずこんな感じ\nhttps://api.twitter.com/1.1/statuses/update.json\n↑このtwitterのapiを叩くだけです！\n非公式だけど、このサイトのリファレンスが分かりやすい\nPOST statuses/update - ツイートを投稿する\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  from requests_oauthlib import OAuth1Session, OAuth1 import requests import json import codecs import time import os OAUTH1 = os.environ[\u0026#39;OAUTH1\u0026#39;] OAUTH2 = os.environ[\u0026#39;OAUTH2\u0026#39;] OAUTH3 = os.environ[\u0026#39;OAUTH3\u0026#39;] OAUTH4 = os.environ[\u0026#39;OAUTH4\u0026#39;] SCREEN_NAME = os.environ[\u0026#39;SCREEN_NAME\u0026#39;] def getOauth(): return OAuth1(OAUTH1, OAUTH2, OAUTH3, OAUTH4) def main(): status = \u0026#34;test \\n※このツイートはbotからの自動ツイートです\u0026#34; response = requests.post( f\u0026#39;https://api.twitter.com/1.1/statuses/update.json\u0026#39;, data={\u0026#34;status\u0026#34;:status}, auth=getOauth() ).json() if \u0026#34;errors\u0026#34; in response: print(response) return def lambda_handler(event, context): try: main() except: import traceback traceback.print_exc()   デプロイ\n$xxにはそれぞれ変数設定してください！\naws cloudformation package --template-file ./template.yaml --s3-bucket $DEPLOY_BUCKET_DEV --output-template-file \u0026quot;./packaged.yaml\u0026quot; aws cloudformation deploy --template-file \u0026quot;./packaged.yaml\u0026quot; --stack-name $stack_name --parameter-overrides Oauth1=$OAUTH1 Oauth2=$OAUTH2 \\ $stack_name --parameter-overrides Oauth1=$OAUTH1 Oauth2=$OAUTH Oauth3=$OAUTH3 Oauth4=$OAUTH4 ScreenName=$SCREEN_NAME 実行 お手軽に画面から実行\nうん、よさそう。\nリプライしてみる 次は、リプライができるか試してみます\nリプライする時は、dataにツイートIDを追加します。\nツイートIDを取得 最新のツイートは個人のステータスから取得できたはず\nローカルの適当なpythonで取得\n1 2 3 4 5 6 7 8 9 10 11 12  def main(): response = requests.get( f\u0026#39;https://api.twitter.com/1.1/users/show.json?screen_name={SCREEN_NAME}\u0026#39;, auth=getOauth() ).json() print(json.dumps(response, ensure_ascii=False, indent=4)) if __name__ == \u0026#39;__main__\u0026#39;: main()   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  { ～略～ \u0026#34;status\u0026#34;: { \u0026#34;created_at\u0026#34;: \u0026#34;Wed Feb 19 20:54:10 +0000 2020\u0026#34;, \u0026#34;id\u0026#34;: 1230234142802xxxxxx, \u0026#34;id_str\u0026#34;: \u0026#34;1230234142802xxxxxx\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;test \\n ※このツイートはbotからの自動ツイートです\u0026#34;, \u0026#34;truncated\u0026#34;: false, \u0026#34;entities\u0026#34;: { \u0026#34;hashtags\u0026#34;: [], \u0026#34;symbols\u0026#34;: [], \u0026#34;user_mentions\u0026#34;: [], \u0026#34;urls\u0026#34;: [] }, ～略～ }, ～略～ }   リプライしてみる とりあえず固定で直指定。\n1 2 3 4 5  response = requests.post( f\u0026#39;https://api.twitter.com/1.1/statuses/update.json\u0026#39;, data={\u0026#34;status\u0026#34;:status,\u0026#34;in_reply_to_status_id\u0026#34;,1230234142802xxxxxx}, auth=getOauth() ).json()   うん、いい感じ\nちゃんと返信先も付いてる！\n続きはお昼\n","description":"","id":29,"section":"posts","tags":["Python","twitter","lambda"],"title":"twitter apiでリプライ twitterBot①","uri":"https://encr.jp/blog/posts/20200220_morning/"},{"content":"adsenseが表示されない… 表示されるところもあるんだけど、ヘッダーとか、表示されない…。\nclomeでエラー確認 とりあえず、エラーを確認。\nサイズがないって言われてる？\nレスポンシブにしてるから、サイズの上限なくて怒られてるのかも？\nとりあえずサイズ固定にしてみる とりあえず、サイズ固定にしてみる。\n場所の確認 そもそも場所がいけなかったかも。\nそれぞれ見直す。\n1 2 3 4 5 6 7 8  {{ if .subtitle }} {{ range .subtitle }} \u0026lt;div class=\u0026#34;site-header__subtitle\u0026#34; style=\u0026#34;font-size: {{ $header.subtitleFontSize }}px; {{ with $header.subtitleColor }}color:{{ . }}{{ end }}\u0026#34; data-cursive=\u0026#34;{{ with $header.subtitleCursive }}{{ . }}{{ end }}\u0026#34;\u0026gt; {{ . }} {{ partial \u0026#34;google/adsense_small\u0026#34; . }} \u0026lt;/div\u0026gt; {{ end }} {{ end }}   ヘッダーはサブタイトルの中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;ul class=\u0026#34;sidebar\u0026#34;\u0026gt; {{ partial \u0026#34;google/adsense_big\u0026#34; . }} {{ partial \u0026#34;search/site-search\u0026#34; . }} {{ partial \u0026#34;sidebar/custom-list\u0026#34; . }} {{ if and ($.Param \u0026#34;itemsPerCategory\u0026#34;) ($.Param \u0026#34;enableListSidebarTitles\u0026#34;) }} {{ range first ($.Param \u0026#34;itemsPerCategory\u0026#34;) .Pages }} \u0026lt;li class=\u0026#34;sidebar-recent\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34; class=\u0026#34;sidebar-recent__title p1\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; \u0026lt;/li\u0026gt; {{ end }} \u0026lt;hr class=\u0026#34;hr-fade sidebar-hr\u0026#34; /\u0026gt; {{ end }} \u0026lt;/ul\u0026gt;   1 2 3 4 5 6 7 8 9 10  \u0026lt;div class=\u0026#34;toc__flexbox\u0026#34; data-position=\u0026#34;{{ if $.Param \u0026#34;hideToc\u0026#34; }}absolute{{ else }}fixed{{ end }}\u0026#34;\u0026gt; {{ partial \u0026#34;google/adsense_big\u0026#34; . }} \u0026lt;h6 class=\u0026#34;toc__title\u0026#34;\u0026gt;{{ i18n \u0026#34;toc-label\u0026#34; }}\u0026lt;/h6\u0026gt; {{ if $.Param \u0026#34;enableTocSwitch\u0026#34; }} \u0026lt;label class=\u0026#34;switch\u0026#34;\u0026gt; \u0026lt;input id=\u0026#34;toggle-toc\u0026#34; aria-label=\u0026#34;Toggle TOC\u0026#34; type=\u0026#34;checkbox\u0026#34; {{ if $.Param \u0026#34;hideToc\u0026#34; }}{{ else }}checked{{ end }}\u0026gt; \u0026lt;span class=\u0026#34;slider round\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/label\u0026gt; {{ end }} \u0026lt;/div\u0026gt;   サイドバーはそれぞれのdivの中\nビルドしてみる うん、よさそう。\nローカル実行だと、広告は表示されないのだー\n空白になってるから、多分表示されるはず！\nこれは単純にコードの場所の問題だったかもな…。\nよし、アップしよう。\nはみ出る… 固定サイズ駄目だったな…\n戻して寝よう…。\n今日の作業はおしまい。\n実はちょっとtwitterBotも進めてるから、明日アップしよー\n追記 いい感じ\n","description":"","id":30,"section":"posts","tags":["hugo","adsense"],"title":"adsenseがヘッダーに表示されないバグ修正","uri":"https://encr.jp/blog/posts/20200219_night/"},{"content":"先日adsenseに合格し、自動広告のみ設定しているのですが、ページビュー286に対し、広告表示数が66…。\n5回に一回しか表示すらされていないじゃないか…\nということで、ヘッダーやサイドバーに広告を追加していきたいと思います。\npcから見たページを確認 こんな感じ\nこの黄色い部分に広告を追加したい！\n広告ユニットを作成 adsenseのページでタグを取得\nここで、広告ユニットを作成します。「広告」⇒「広告ユニット」⇒「ディスプレイ広告」\n↓のマーク部分を設定し作成。\nすると、タグが表示されます。コピーしておきます。\n私はヘッダーように横長。サイドバー用にスクエア。の二つを作成しました。\nタグを設置 テーマの中にlayouts/partials/googleフォルダを作り、その中に新しいhtmlファイルを作成。\nその中にコピーしたタグを設置します。\nとりあえず、layouts/partials/google/adsense_big.htmlにスクエアを。\nlayouts/partials/google/adsense_small.htmlに横長を設置。\nタグの設置位置を確認 どこに追加すれば、いい感じに位置に入るのか、とりあえずいろんなところにpタグを追加して、確認してみる。\nいつかちゃんとまとめるかもしれないけど、今日は細かい調査結果は割愛。\nそろそろ仕事行かないとだし…\n結果だけ書きます。\ncustom-xx.htmlでは欲しい場所に入ってくれなかったので、直接本体を書き換えました。\nヘッダー\nlayouts/partials/header/header-text.html\nサイドバー(topページ)の頭\nlayouts/partials/sidebar/sidebar-home.html\nサイドバー(topページ)の真ん中\nlayouts/partials/sidebar/custom-home.html\nサイドバー(記事ページ)\nlayouts/partials/sidebar/sidebar-single.html\n↑のそれぞれのページに\n{{ partial \u0026quot;google/adsense_big\u0026quot; . }} を追加しました。(ヘッダーだけはsmall)\nお昼か夜にちゃんとまとめるかも！\nスマホ版の全画面広告を無効に 表示数稼ぐために設定してたけど、やっぱり、どう考えてもこれうざい！\nだから、消しました！\nこの全画面広告出ると、続き見る気なくなるもんね…ww\nここで消します。\nadsenseから、「広告」⇒「サイトごと」で、対象サイトを選択後、↓のチェックボックスを外します。\n独り言 よし、多分できた！\n仕事行ってきます！\n","description":"","id":31,"section":"posts","tags":["hugo","adsense"],"title":"pc版ブログにadsense広告を追加する！","uri":"https://encr.jp/blog/posts/20200219_morning/"},{"content":"前回の記事のアイキャッチがひどい… この文字化けかのごときurl…\nこの画像自動生成は、マークダウンの記事をそのまま出力してるからね…\nなので、単純な話だけど、urlのリンク([リンクの文字列](ページのリンク))と画像のリンク(![画像の名前](画像のリンク))を正規表現で置き換える。\n1 2 3 4 5  base_text = base_text.replace(\u0026#34;\\n\\n\u0026#34;, \u0026#34;\\n\u0026#34;) base_text = re.sub(\u0026#39;\\!\\[.+\\]\u0026#39;,\u0026#39;\u0026#39;,base_text) base_text = base_text.replace(\u0026#34;[\u0026#34;, \u0026#34;\u0026#34;) base_text = base_text.replace(\u0026#34;]\u0026#34;, \u0026#34;\u0026#34;) base_text = re.sub(\u0026#39;\\(.+\\)\u0026#39;,\u0026#39;\u0026#39;,base_text)   正規表現についてはこの辺を参考に。\nうん、まぁ、こんな感じかな？\n独り言 短いけど、今日はこれでおしまい。\n細かいけど、タグを追加した！\n記事のテンプレートも直した！\n1 2 3 4 5 6 7 8 9  --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} meta_image: \u0026#34;posts/meta_image/{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}.png\u0026#34; tags: [\u0026#34;hugo\u0026#34;,\u0026#34;Python\u0026#34;,\u0026#34;twitter\u0026#34;,\u0026#34;aws\u0026#34;] categories: [\u0026#34;hugoブログ\u0026#34;,\u0026#34;lineBot\u0026#34;,\u0026#34;twitter_api\u0026#34;,\u0026#34;メール\u0026#34;] draft: true ---   でも、タグ追加したら、タグにはクロール禁止付けておかないとな…\n明日やろう。\nいやぁ、やることほんとにたくさん…。\n","description":"","id":32,"section":"posts","tags":["Python"],"title":"画像生成時にリンクを無視する　twitterカード画像自動生成⑦","uri":"https://encr.jp/blog/posts/20200218_night/"},{"content":"forkwellとは？ こちら の求人サイト。\n登録で2000円のアマゾンギフト券もらえたりします。\nポートフォリオの登録が出来て、そのポートフォリオをみた企業がスカウトを送ってきてくれるという素敵なサイトです。\nアマゾンギフト券欲しい方は、登録の上、この招待コードを入れてくれればww\n招待コード「GJJNYT」\nあとね、スカウトメールを受けて、面接とか見学とかで会社に行くと、一回1000円もらえる！\n今度、スカウトくれた会社めぐりしようかなーと企み中ww\nそれはさておき…。\nブログをアウトプットとして登録できる RSSがついているブログはアウトプットとして登録できるらしい。\nで、やってみた。\nだめっぽい\nRSSつけよう RSS付けよう！\nと思って、色々調べたら…\nなんと、zzoには標準でついているはず…\nでも、\n連携されない…\nこれはrss機能してないのでは？？\nRSSのアドレスを調べる フッターのボタンを押すと、エラーになって、「https://encr.jp/blog//index.xml」にアクセスしてるみたいなの…。\nなんでかね…。\nただ、//がまぁおかしいんだろうなって思って、「https://encr.jp/blog/index.xml」にアクセスしたら、xmlがありました。\nきっとリンクが間違ってるねー\n直したいけど、今はまずforkwell\nRSSのアドレスは「トップページ/index.xml」みたい。\nforkwellと連携 アドレス分かったから、トップページじゃなくて、直接xmlのアドレスを指定してみる。\nできた！\n技術的なこと何もしてないけど…\nご飯食べたら、↑のアドレス間違ってる問題の対応しましょうかねw\n","description":"","id":33,"section":"posts","tags":["forkwell"],"title":"forkwellとこのブログを連携","uri":"https://encr.jp/blog/posts/20200218_morning/"},{"content":"このブログもだけど、ロリポップみたいなレンタルサーバーを借りてないので、メールサーバーも使えないのです。\nなので、メールもawsで受信してます。\nお値段なんと0円ww\nで、htmlメールが綺麗に受信できないので、対策しようかなと思っているところです。\n今日は、まずその前に、今の現状をまとめておこうと思います！\n構成 こんな感じ？\nroute53で独自ドメインを設定して、SESで受信して、SNSのtopicに内容投げて、SQSがサブスクリプションして、lambdaに投げて、lambdaでメールの内容読み取って、SNSに送って、サブスクリプションで別のメールに転送してます。\n長い…ww\nあと、一応、SESから一応s3にバックアップ保存してます。\nSESって実は東京リージョンになくって…。\nで、lambdaって同一リージョンからじゃないと叩けなくて…。\nなので、SESとSNSまではオレゴン。その先は東京という不思議なつくりになっていますww\nなんで全部オレゴンで完結してはいけないのかというと、受信したメールを東京リージョンの別のlambdaやdynamoに連携したいって言う、次の目標があるからww\nメール読み取りlambda ソースはこんな感じ\nで、これだとhtmlメールが綺麗に受信できないのと、タイトルと宛先と受信元と…とかの情報が取れないのが今の課題…。\n今度この辺をなんとかする！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  import json import email import boto3 def lambda_handler(event, context): print(json.dumps(event)) message = json.loads(event[\u0026#34;Records\u0026#34;][0][\u0026#34;body\u0026#34;]) print(message) email_body = message[\u0026#34;content\u0026#34;] email_object = email.message_from_string(email_body) body = \u0026#34;\u0026#34; for part in email_object.walk(): # ContentTypeがmultipartの場合は実際のコンテンツはさらに # 中のpartにあるので読み飛ばす if part.get_content_maintype() == \u0026#39;multipart\u0026#39;: continue # ファイル名の取得 attach_fname = part.get_filename() # ファイル名がない場合は本文のはず if not attach_fname: charset = str(part.get_content_charset()) if charset: body += part.get_payload(decode=True).decode(charset, errors=\u0026#34;replace\u0026#34;) else: body += part.get_payload(decode=True) else: # ファイル名があるならそれは添付ファイル pass print(body) TOPIC_ARN = os.environ[\u0026#39;TOPIC_ARN\u0026#39;] client = boto3.client(\u0026#39;sns\u0026#39;) response = client.publish( TopicArn = TOPIC_ARN, Message = body, Subject = \u0026#34;メール受信\u0026#34; ) return { \u0026#39;statusCode\u0026#39;: 200 }   こんな感じのメールが来ます。\n色々と改善頑張る回はこちら\n","description":"","id":34,"section":"posts","tags":["Python","aws"],"title":"0円メールサーバー。メールアドレス数無限ww","uri":"https://encr.jp/blog/posts/20200217_night/"},{"content":"twitterカード画像自動生成機能は画像を自動生成するだけなので、各記事のheaderにmeta_imageを自力で設定しないといけなかった。\nそこもいい感じにしてくれるようにする。\nhugo newのカスタマイズ hugoでは\nhugo new xx.md とすることで、xxという記事のテンプレートが出来上がる。\nこのテンプレートの設定を変えてみる。\nテンプレートの作成元 テンプレートの作成元のベースになるのは\narchetypes/default.md\nというファイル\nデフォルトだと、こんな感じになっていると思う。\n1 2 3 4 5  --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} draft: true ---   この状態で、hugo newすると、こんなファイルが出来上がる。\n$ hugo new posts/test.md /mnt/c/github/runau/hugo/tweetBlog/content/posts/test.md created 1 2 3 4 5  --- title: \u0026#34;Test\u0026#34; date: 2020-02-17T17:21:17+09:00 draft: true ---   default.mdの{{}}にいい感じの値を埋め込んでくれているのがわかる。\nテンプレートの作成元の編集 ここに、meta_imageの記載を追加する。\n1 2 3 4 5 6  --- title: \u0026#34;{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#34; date: {{ .Date }} meta_image: \u0026#34;posts/meta_image/{{ replace .Name \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}.png\u0026#34; draft: true ---   で、もう一度hugo new\n$ hugo new posts/test.md /mnt/c/github/runau/hugo/tweetBlog/content/posts/test.md created 1 2 3 4 5 6  --- title: \u0026#34;Test\u0026#34; date: 2020-02-17T17:21:17+09:00 meta_image: \u0026#34;posts/meta_image/Test.png\u0026#34; draft: true ---   できた。\nこれで、このまま記事を書いて、build.shを叩けば、アイキャッチが自動生成＆自動設定される。\ntwitterカード画像自動生成機能の残作業  アイキャッチ更新不要の場合はわざわざ作らない対応 微妙に左上が欠ける問題の解消  独り言 日本酒が飲み放題の夢の世界から帰ってきてしまいました…。\n現実に戻って、晩御飯作ります…。\nご飯食べたら、もうひと作業したいな…\n","description":"","id":35,"section":"posts","tags":["Python","hugo"],"title":"hugo newのカスタマイズ　twitterカード画像自動生成機能⑥","uri":"https://encr.jp/blog/posts/20200217_lunch/"},{"content":"昨日作った画像生成スクリプトの残作業を進める\nビルドコマンドと昨日のスクリプトをshでラッピングする 指定したディレクトリ内のファイルに対して、画像生成スクリプトを回し、最後にビルドする。\nいつも忘れるシェルのループの書き方はこの辺を参考に。\nシェルスクリプトのforループでフォルダやファイルを一括処理\nで、作った！\n1 2 3 4 5 6 7 8 9 10 11 12 13  #!/bin/sh dir_path=\u0026#34;content/posts/*\u0026#34; dirs=`find $dir_path -maxdepth 0 -type f -name *.md` for dir in $dirs; do echo $dir python create_meta_image.py $dir done hugo -t zzo   create_meta_image.pyの修正 echo $dirのところ、パスが取れちゃって、\ncontent/posts/20200216_morning.md\nみたいな感じのが取れるから、shで正規表現で抽出するのめんどくさくて、pythonの方を修正。\n1 2 3 4 5  target = sys.argv[1] print(f\u0026#34;target:{target}\u0026#34;) target = target.split(\u0026#34;/\u0026#34;)[-1] target = target.replace(\u0026#34;.md\u0026#34;,\u0026#34;\u0026#34;)   これで、ディレクトリ付き(content/posts/20200216_morning.md)でも、なし(20200216_morning)でも、どっちでもいい感じに処理してくれるはずww\nで、このスクリプト回して、全記事のアイキャッチ更新して、\nはい、今日の朝活おわり！\n朝風呂言って来よう！せっかく温泉来てるしねww\n残作業  アイキャッチ更新不要の場合はわざわざ作らない対応 hugo newした時にmeta_imageを設定する  ","description":"","id":36,"section":"posts","tags":["Python","bash","hugo"],"title":"画像生成スクリプトをビルド時に動かす　twitterカード画像自動生成機能⑤","uri":"https://encr.jp/blog/posts/20200217_morning/"},{"content":"朝作ったスクリプトをいい感じで自動で動かす方法を考える！\n朝の記事は こちら\n引数を渡す まずは、引数渡せるようにして、いい感じのファイルを作れるようにする。\nとりあえずファイル名を指定できるようにする。\nimport sys target = sys.argv[1] print(f\u0026quot;target:{target}\u0026quot;) で、\nimg.save(f\u0026quot;content/posts/meta_image/{target}.png\u0026quot;) これで、対象の記事に対してスクリプトが動く\ntargetのmdからタイトルと内容を取得 で、マークダウンを読み取る\nもしかしたら、もっといいベストプラクティスがあるのかもしれないけど…。\nとりあえず、テキストとして読み取って、ヘッダー部分をyamlとして読み込み直す\nこんな感じ？\nimport yaml with open(f'content/posts/{target}.md') as f: md = f.read().split(\u0026quot;---\u0026quot;) header_yaml = md[1] body = md[2] header = yaml.load(header_yaml) title = header[\u0026quot;title\u0026quot;] で、タイトルと、内容を取得\n引数に設定\n実行\nおおお！いいね\n完成(ㅅ´ ˘ `)♡\nちょっと細かいリファクタリングとか、バグ取りとかして、こんな感じ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  from PIL import ImageFont, ImageDraw, Image import sys import yaml def add_text_to_image(img, base_text, font_path, font_size, font_color, height, width, line=1, max_length=800, max_height=420): font = ImageFont.truetype(font_path, font_size) draw = ImageDraw.Draw(img) lineCnt = 1 base_text = base_text.strip() base_text = base_text.replace(\u0026#34;\\n\\n\u0026#34;, \u0026#34;\\n\u0026#34;) base_text = base_text[0:150] break_flg = False for lineCnt in range(line): text = base_text.split(\u0026#34;\\n\u0026#34;)[0] position = (width, height) if len(text) == 0: break if lineCnt == line - 1 or \\ height + draw.textsize(text, font=font)[1] \u0026gt; max_height: if draw.textsize(text, font=font)[0] \u0026gt; max_length: # テキストの長さがmax_lengthより小さくなるまで、1文字ずつ削っていく while draw.textsize(text + \u0026#39;…\u0026#39;, font=font)[0] \u0026gt; max_length: text = text[:-1] text = text + \u0026#39;…\u0026#39; break_flg = True else: while draw.textsize(text, font=font)[0] \u0026gt; max_length: text = text[:-1] base_text = base_text.replace(text, \u0026#34;\u0026#34;) base_text = base_text.strip() height = height + draw.textsize(text, font=font)[1] draw.text(position, text, font_color, font=font) print(f\u0026#34;draw:{text}\u0026#34;) if break_flg: break return img, height target = sys.argv[1] print(f\u0026#34;target:{target}\u0026#34;) with open(f\u0026#39;content/posts/{target}.md\u0026#39;) as f: md = f.read().split(\u0026#34;---\u0026#34;) header_yaml = md[1] body = md[2] header = yaml.load(header_yaml) title = header[\u0026#34;title\u0026#34;] base_img_path = \u0026#34;content/posts/meta_image/base.png\u0026#34; base_img = Image.open(base_img_path).copy() font_path = \u0026#34;content/posts/meta_image/meiryo.ttc\u0026#34; font_color = (88, 110, 117) height = 155 width = 30 font_size = 57 line = 3 img, height = add_text_to_image( base_img, title, font_path, font_size, font_color, height, width, line) font_size = 35 height = height + 20 line = 6 img, height = add_text_to_image( img, body, font_path, font_size, font_color, height, width, line) img.save(f\u0026#34;content/posts/meta_image/{target}.png\u0026#34;)   このまま投稿してみる！\n出来たヾ(●´∇｀●)ﾉ\n残タスク  今はmdのテキストをそのまま出力しているので、リンクの中身を臭力しないようにするとか♯をいい感じにするとか。 shでラッピングして、ビルド時にいい感じに自動生成するようにする。 既にイメージができている時は作りなおさずにスキップする  とか\nとりあえず、今日はこんなもん。\nよし、夜鳴きそば食べて来ようwww\n","description":"","id":37,"section":"posts","tags":["Python","bash","hugo"],"title":"twitterカード画像自動生成機能を記事ごとに動かす　twitterカード画像自動生成機能④","uri":"https://encr.jp/blog/posts/20200216_lunch/"},{"content":"昨日あれから、寝る前にどうやるか、よく考えた。\nで、思った。\nどうせバッチっぽいの回すなら、jsでなくてよくね？？\nPythonで画像に文字描画 という事でPythonでできないか調べた\n「Python 画像 文字描画」とかで検索\nなんかね、簡単に出来そう！\nよーし、日曜日だし、これから越後湯沢に旅行だけど、気合い入れて作るぞー！！\n先人様がいらっしゃるので、参考にさせて頂く\nPythonで画像を編集したり、文字を入れたりする\nまずベースの画像を作って、文字を重ねる\nベースの画像は、とりあえずこんな感じでいいか？\nで、文字を描画してみる\nとりあえず、↑サイトから取ってきたコードのパスとかサイズとかだけ調整しただけのコードでお試し！\nと思ったけど、フォントファイルがない…\nよく分かんないから、もうネットで探すww\nここにあったのを拾う\nメイリオのフォントファイル\nで、適当において、パスを指定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  from PIL import ImageFont,ImageDraw,Image def add_text_to_image(img, base_text, font_path, font_size, font_color, height, width,max_length=800): font = ImageFont.truetype(font_path, font_size) draw = ImageDraw.Draw(img) if draw.textsize(text, font=font)[0] \u0026gt; max_length: while draw.textsize(text + \u0026#39;…\u0026#39;, font=font)[0] \u0026gt; max_length: text = text[:-1] text = text + \u0026#39;…\u0026#39; return img title = \u0026#34;titlexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; font_path = \u0026#34;content/posts/meta_image/meiryo.ttc\u0026#34; font_size = 57 font_color = (88, 110, 117) height = 155 width = 30 path = \u0026#34;content/posts/meta_image/base.png\u0026#34; base_img = Image.open(path).copy() img = add_text_to_image(base_img, title, font_path, font_size, font_color, height, width) img.save(\u0026#34;content/posts/img/create.png\u0026#34;)   うん、いい感じ\n指定行数まで折り返す どうやら、↑のサイトでは、長い文字は切り落としているみたい\nでも、長い文字は折り返したい！\nちょっとコード変更\nこれでlineに指定した行数分折り返してくれる\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  from PIL import ImageFont,ImageDraw,Image def add_text_to_image(img, base_text, font_path, font_size, font_color, height, width, line,max_length=800): font = ImageFont.truetype(font_path, font_size) draw = ImageDraw.Draw(img) for lineCnt in range(line): print (lineCnt) text = base_text position = (width, height) if lineCnt == line: # テキストの長さがmax_lengthより小さくなるまで、1文字ずつ削っていく while draw.textsize(text + \u0026#39;…\u0026#39;, font=font)[0] \u0026gt; max_length: text = text[:-1] text = text + \u0026#39;…\u0026#39; else: while draw.textsize(text , font=font)[0] \u0026gt; max_length: text = text[:-1] base_text = base_text[1:] height = height + draw.textsize(text , font=font)[1] draw.text(position, text, font_color, font=font) return img title = \u0026#34;titlexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; font_path = \u0026#34;content/posts/meta_image/meiryo.ttc\u0026#34; font_size = 57 font_color = (88, 110, 117) height = 155 width = 30 path = \u0026#34;content/posts/meta_image/base.png\u0026#34; base_img = Image.open(path).copy() line = 3 img = add_text_to_image(base_img, title, font_path, font_size, font_color, height, width, line) img.save(\u0026#34;content/posts/meta_image/create.png\u0026#34;)   実行\nこんな感じ\nうん、いい感じ\n内容もつくる さっきまで作ってたのはタイトル。\nでその下に、ちょっと文字を小さくして本文を入れたい！\nせっかく関数化してあるしね。もう一回呼び出すように変更。\nで、文字の高さの位置が変わるから、それもリターンするようにする。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  from PIL import ImageFont, ImageDraw, Image def add_text_to_image(img, base_text, font_path, font_size, font_color, height, width, line=1, max_length=800): font = ImageFont.truetype(font_path, font_size) draw = ImageDraw.Draw(img) lineCnt = 1 for lineCnt in range(line): print(lineCnt) text = base_text position = (width, height) if lineCnt == line - 1: # テキストの長さがmax_lengthより小さくなるまで、1文字ずつ削っていく while draw.textsize(text + \u0026#39;…\u0026#39;, font=font)[0] \u0026gt; max_length: text = text[:-1] text = text + \u0026#39;…\u0026#39; else: while draw.textsize(text, font=font)[0] \u0026gt; max_length: text = text[:-1] base_text = base_text[1:] height = height + draw.textsize(text, font=font)[1] draw.text(position, text, font_color, font=font) return img, height title = \u0026#34;titlexxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; font_path = \u0026#34;/mnt/c/github/runau/hugo/tweetBlog/content/posts/meta_image/meiryo.ttc\u0026#34; font_size = 57 font_color = (88, 110, 117) height = 155 width = 30 path = \u0026#34;/mnt/c/github/runau/hugo/tweetBlog/content/posts/meta_image/base1.png\u0026#34; base_img = Image.open(path).copy() line = 2 img, height = add_text_to_image( base_img, title, font_path, font_size, font_color, height, width, line) title = \u0026#34;bodyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; font_path = \u0026#34;/mnt/c/github/runau/hugo/tweetBlog/content/posts/meta_image/meiryo.ttc\u0026#34; font_size = 40 font_color = (88, 110, 117) height = height + 20 width = 30 path = \u0026#34;/mnt/c/github/runau/hugo/tweetBlog/content/posts/meta_image/base1.png\u0026#34; base_img = Image.open(path).copy() line = 5 img, height = add_text_to_image( img, title, font_path, font_size, font_color, height, width, line) img.save(\u0026#34;/mnt/c/github/runau/hugo/tweetBlog/content/posts/meta_image/create.png\u0026#34;)   実行\nこんな感じ\nうん、いいね。\n旅行出発の時間だ。\nこのバッチを呼び出すところとか、引数とかそういうのは次の作業で！\n","description":"","id":38,"section":"posts","tags":["Python","hugo"],"title":"twitterカード自動生成機能作った　twitterカード画像自動生成機能③","uri":"https://encr.jp/blog/posts/20200216_morning/"},{"content":"朝の続き。\n朝活の後、カラオケオフ会に行ってきましたよw\nうん、やっぱり楽しい！\n歌、上手くなりたいなー…\nさて、twitterカードの画像を自動生成したいというお話。\n完成イメージの方針 大きく二つ\n スクショを取る 画像を作成する  どっちでもいいから、楽な方にしたいんだけど…\nとりあえず両方考える！\nスクショを撮る こんな感じ\nブログの画面をスクショして、画像にして、それをカードに設定したい！\npythonでライブラリあるみたいだから、動的サイトのスクレイピングの要領で、画面表示して、スクショ取ればいいみたい！\nできそう！だけど、lambdaでやるのは現実出来ではないかな…\nま、スクレイピング環境も作りたいから、合わせてecrで対応するのとかもよさげだけど…\nいったんやめよう\n画像を作成する こんな感じ\nキータはね、分かりやすいし可愛いよね\nこういうの作りたい！\nQiitaは imgix\nここでなんかしているらしい…\nでもね、これ、月額10ドルから…\n諦めよう…ww\nでも、なんでもよければ、実は前にワードプレスで作ったんだよね。\nアイキャッチ自動生成ツール\nもう、記事ごとのアイキャッチ設定するのが本当にめんどうだったから、記事投稿時に、タイトルとカテゴリから勝手にアイキャッチ作ってくれるの作ったの\nあれと同じ感じで作れるはず。\ncanvasに描画⇒pngに変換\n画像が作れれば何でもいいんだけれど、全く知らない技術より、一回やったことあるものの方が工数削減のはず！\nとりあえず、この方針で勧める。\nということで 画像作成の方向で…\nタイミング ワードプレスの時は記事保存時に動かしてたんだけど、今回はどうしたもんか…\n  記事書いた後、build前にローカルでshかなんかで作って埋め込む\n  build時に絡める\n  build後にローカルでshかなんかで作って埋め込む\n  s3put時にputイベントで作る\n  html読み込んだ時に作る？できるのか？\n  うむ。\nbuild時に絡めるは一番綺麗だろうけど、私には無理そうだから…\ns3put時にputイベントもなかなか楽しそうだけど…。\nでも一番楽なのは、ビルド前に何か動かすかな。\nとりあえず、その方向で考える\n何を作るか？   全記事を取得⇒画像がなかったら画像作成\n  ビルド時にmetaタグにそれぞれの画像を設定\n  metaタグは、ビルド時に生成されるから、なんとかいい感じの参照をしてくれるようにしないと。\nまずそこから試そう！\nmetaタグを記事ごとに設定 今は、twitterカードの画像は、params.tomlで設定されてて、全記事共通の画像しか参照できない。\nここを変える方法を考える。\nとりあえずmetaタグを設定しているmeta.htmlを眺める。\n………。\nうーん、goさっぱり分らん…。\ngoの勉強から始めなきゃダメなのか…？？\nで、よく分かんないけど、アイキャッチって記事ごとに設定したいもんだし、とりあえず記事のヘッダーに追加してみたw\n1 2 3 4 5  --- title: \u0026#34;Twitterカードの画像の自動生成機能を考える\u0026#34; date: 2020-02-15T19:00:55+09:00 meta_image: \u0026#34;meta_image/20200215_lunch.png\u0026#34; ---   そしたらいい感じにできたw\nわーい//\nそりゃそうだよね。記事ごとに設定しないといけないもんね。\n記事のヘッダーは、params.tomlを上書きする設定ってイメージなのかね。\n最後に いや、ほんと\nマークダウンでブログが書けるって素晴らしさねw\n同じ記事量でも、ワードプレスの時はもっと時間かかってたわー\n毎日3記事upとか、マークダウンだからこそ、できる技ですなwww\n次の記事で自動生成作る！\n","description":"","id":39,"section":"posts","tags":["Python"],"title":"Twitterカードの画像の自動生成機能を考える　twitterカード画像自動生成機能②","uri":"https://encr.jp/blog/posts/20200215_lunch/"},{"content":"hugoのzzoでtwitterカードを設定する！ 今はこんな感じ…\n可愛くない…\n可愛くしたい！\nちなみに、twitter上にどう表示されるか？は以下のツールで確認できます！\ntwitter公式Card validator\n画像の自動生成とかしたいんだけど、長くなりそうだから、まずは固定の画像と固定のディスクリプションの追加。\n自動生成は午後にやろうー！\ntwitterカードの種類をラージに twitterカードには種類が4種類あって、ブログで使われるのは2種類\n Summary Card Summary Card with Large Image  細かいことはサルワカさんの↓の記事とか見てもらえればw\nこの人は本当にすごくてw\n3年前に初めてワードプレスでブログ書いた時からお世話になっているww\nサルワカさんブログ\nで、今はSummary Cardだけど、Summary Card with Large Imageにしたいのね。\ncustom-header 1 2  \u0026lt;meta name=\u0026#34;twitter:card\u0026#34; content=\u0026#34;summary_large_image\u0026#34;\u0026gt; \u0026lt;meta content=\u0026#34;@encr\u0026#34; name=\u0026#34;twitter:site\u0026#34; /\u0026gt;   とりあえず追加してみる\nビルドして、clomeで開いて、ソースを確認\nうん、大丈夫そう\nと思ったけど… 1 2 3 4 5 6 7 8 9 10 11 12 13 14  {{ with $.Param \u0026#34;contact\u0026#34; }}\u0026lt;meta name=\u0026#34;contact\u0026#34; content=\u0026#34;{{ . }}\u0026#34;\u0026gt;{{ end }} \u0026lt;meta property=\u0026#34;og:site_name\u0026#34; content=\u0026#34;{{ .Site.Title }}\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:title\u0026#34; content=\u0026#34;{{ .Title }}\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:url\u0026#34; content=\u0026#34;{{ .Permalink | absLangURL }}\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:type\u0026#34; content=\u0026#34;{{ if .IsPage }}article{{ else }}website{{ end }}\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:description\u0026#34; content=\u0026#34;{{ $.Param \u0026#34;description\u0026#34; }}\u0026#34;\u0026gt; {{ with $.Param \u0026#34;meta_image\u0026#34; }} \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;{{ . | absURL }}\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;og:image:url\u0026#34; content=\u0026#34;{{ . | absURL }}\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;twitter:card\u0026#34; content=\u0026#34;summary_large_image\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;twitter:app:name:iphone\u0026#34; content=\u0026#34;{{ $.Site.Title }}\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;twitter:title\u0026#34; content=\u0026#34;{{ $.Param \u0026#34;title\u0026#34; }}\u0026#34;\u0026gt; \u0026lt;meta property=\u0026#34;twitter:description\u0026#34; content=\u0026#34;{{ $.Param \u0026#34;description\u0026#34; }}\u0026#34;\u0026gt; {{ end }}   こんなのあった\nこれ、自力で頑張らなくてもいい奴だな…\nなんかよく分かんないけど、とりあえず\n{{ with $.Param \u0026ldquo;meta_image\u0026rdquo; }}\nに入って欲しいから、params.tomlにmeta_imageでも追加してみる？\n1  meta_image = true   テストビルドして実行\nできたw\nでもよく見ると、画像のアドレスがtrueだわw\nこれ、画像のパス設定するのねw\n画像追加する とりあえず、まずは適当な画像を用意。\nで、これを設定\n1  meta_image = \u0026#34;posts/img/meta-image.png\u0026#34;   よし、ビルドしてアップしてみよう\nよし！\nただ…。\nTwitterに貼ると変わらない…\n反映に時間かかる系かもしれないな。\nそう信じて、一日くらい様子見てみようか…\n次は画像の自動生成する！\n後日追記 1時間くらいしたら反映されました。\ntwitter公式Card validator\nを表示することで、反映が早くなるようです。\n早く反映したい場合は、↑ツールでtwitter上のキャッシュクリアをしてみてください！\n","description":"","id":40,"section":"posts","tags":["hugo"],"title":"Twitterカードの設定　twitterカード画像自動生成機能①","uri":"https://encr.jp/blog/posts/20200215_morning/"},{"content":"今日adsense対策しようと思って、とりあえず昨日の夜、無理やり広告タグ貼り付けて審査出すだけだしたんだけど、受かったよねww\n昔のブログは30記事近く書いてやっと審査通ったのに…\n技術ブログはなかなか丸かぶりな記事ないから、甘いのかな？w\nとりあえず、やったこととかまとめる\nhugoのzzoテーマでタグを貼る hugoはmdで記事を書いて、その記事からビルドでhtmlやらjsやらを自動生成してくれるという仕組み。\nさて、どこに何を書いたもんか…\nとなったんだけど、zzoは簡単な方法があった！\n少し、テーマの中身をいじることになる。\nlayouts/partialsの中にhtmlのパーツを置くことができるみたいなので、まず、adsenseのパーツを新規で作る\n1 2  \u0026lt;script async src=\u0026#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script data-ad-client=\u0026#34;ca-pub-xxxxxxxxxxxx\u0026#34; async src=\u0026#34;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   xxxxxは自分のコードに変えてくださいね！\nで、そのパーツを呼び出す。\nzzoはよくできていて、custom-head.htmlに書くだけでいいみたい。\n他のテーマの場合は、っぽいことが書いてあるところに、同じように↓の記述を追加すればOK\n1 2 3  \u0026lt;!--override this file --\u0026gt; \u0026lt;!--Adsense --\u0026gt; {{ partial \u0026#34;google/adsense\u0026#34; . }}   で、ビルドするだけ！\n自動広告 自動広告は↑の記述さえしてしまえば、adsense側で設定するだけでいいから、これでおしまい！\n設定は、adsenseの管理画面⇒広告⇒該当サイトの右端の鉛筆マークでできます。\nただね、hugoは綺麗な自動広告入ってくれないみたい…\nスマホしか自動広告出なくて、\n私の大嫌いな画面全体の広告と、画面下の広告がでているよw\nでね、最近snowflake universityばっか見てたから、snowflakeの宣伝ばっかりwww\nとりあえず、しばらくはこのまま広告出しておくので、よかったら参考にして下さい！\n明日はほどよい感じで広告を入れるか、↑と同じ感じでcustum-headerで、twitterカードの設定をしたいな…\n","description":"","id":41,"section":"posts","tags":["adsense","hugo"],"title":"hugo/zzoブログでadsense審査通ったw","uri":"https://encr.jp/blog/posts/20200214_night/"},{"content":"実は昨日も頑張ったんだけど…。\nその続き\nhugo/zzoのタイトルとプロフィールを変更\nとりあえず、タイトルは表示されたんだけど、スマホだと見切れてしまうの…。\n絶対ダメでしょww\nカギはやっぱり、_index.mdだと思うんだよね。\n昨日いじっても、何も変化なかったし…。\nなので、こいつが効くまで頑張る！\nエラー 実はね、エラー出てたんだよね…。\n$ hugo server -D ERROR 2020/02/14 12:32:22 svType != tvType; key=hascjklanguage, st=bool, tt=string, sv=true, tv=true Built in 631 ms Error: Error building site: \u0026quot;/mnt/c/github/runau/hugo/tweetBlog/content/_index.md:19:1\u0026quot;: failed to unmarshal YAML: yaml: line 18: did not find expected key で、19行目以降削除したらエラー出なくなったから、ま、textしか使わないしいいか、と思ってたんだけど、\nだめなのかもな…。\nただのyamlの文法エラーかもしれない？\nvsCodeで確認 vscodeでyamlにして、エラー出ないか確認…\n別にでない…\npythonで確認 手軽にyaml読む方法、pythonしかわからんから、pythonで読んでみる。\nimport yaml yml = yaml.load(open(\u0026quot;/mnt/c/github/runau/hugo/tweetBlog/content/header:.yml\u0026quot;, 'r')) $ python Python 3.6.5 (default, Nov 14 2019, 22:52:14) [GCC 7.4.0] on linux Type \u0026quot;help\u0026quot;, \u0026quot;copyright\u0026quot;, \u0026quot;credits\u0026quot; or \u0026quot;license\u0026quot; for more information. \u0026gt;\u0026gt;\u0026gt; import yaml \u0026gt;\u0026gt;\u0026gt; yml = yaml.load(open(\u0026quot;/mnt/c/github/runau/hugo/tweetBlog/content/header:.yml\u0026quot;, 'r')) Traceback (most recent call last): File \u0026quot;\u0026lt;stdin\u0026gt;\u0026quot;, line 1, in \u0026lt;module\u0026gt; File \u0026quot;/home/lisa/.pyenv/versions/3.6.5/lib/python3.6/site-packages/yaml/__init__.py\u0026quot;, line 72, in load return loader.get_single_data() File \u0026quot;/home/lisa/.pyenv/versions/3.6.5/lib/python3.6/site-packages/yaml/constructor.py\u0026quot;, line 35, in get_single_data node = self.get_single_node() File \u0026quot;/home/lisa/.pyenv/versions/3.6.5/lib/python3.6/site-packages/yaml/composer.py\u0026quot;, line 36, in get_single_node document = self.compose_document() File \u0026quot;/home/lisa/.pyenv/versions/3.6.5/lib/python3.6/site-packages/yaml/composer.py\u0026quot;, line 55, in compose_document node = self.compose_node(None, None) File \u0026quot;/home/lisa/.pyenv/versions/3.6.5/lib/python3.6/site-packages/yaml/composer.py\u0026quot;, line 84, in compose_node node = self.compose_mapping_node(anchor) File \u0026quot;/home/lisa/.pyenv/versions/3.6.5/lib/python3.6/site-packages/yaml/composer.py\u0026quot;, line 133, in compose_mapping_node item_value = self.compose_node(node, item_key) File \u0026quot;/home/lisa/.pyenv/versions/3.6.5/lib/python3.6/site-packages/yaml/composer.py\u0026quot;, line 82, in compose_node node = self.compose_sequence_node(anchor) File \u0026quot;/home/lisa/.pyenv/versions/3.6.5/lib/python3.6/site-packages/yaml/composer.py\u0026quot;, line 110, in compose_sequence_node while not self.check_event(SequenceEndEvent): File \u0026quot;/home/lisa/.pyenv/versions/3.6.5/lib/python3.6/site-packages/yaml/parser.py\u0026quot;, line 98, in check_event self.current_event = self.state() File \u0026quot;/home/lisa/.pyenv/versions/3.6.5/lib/python3.6/site-packages/yaml/parser.py\u0026quot;, line 393, in parse_block_sequence_entry \u0026quot;expected \u0026lt;block end\u0026gt;, but found %r\u0026quot; % token.id, token.start_mark) yaml.parser.ParserError: while parsing a block collection in \u0026quot;/mnt/c/github/runau/hugo/tweetBlog/content/header:.yml\u0026quot;, line 2, column 5 expected \u0026lt;block end\u0026gt;, but found '?' in \u0026quot;/mnt/c/github/runau/hugo/tweetBlog/content/header:.yml\u0026quot;, line 3, column 5 \u0026gt;\u0026gt;\u0026gt; うん。怒られた。\nこれやな\nでも、公式サイトから取ってきただけなんだけどなーー\nしょうがない。yamlの勉強しよう\nyaml入門\nふむふむ。インデントか？\n直して再実行\n\u0026gt;\u0026gt;\u0026gt; yml = yaml.load(open(\u0026quot;/mnt/c/github/runau/hugo/tweetBlog/content/header:.yml\u0026quot;, 'r')) \u0026gt;\u0026gt;\u0026gt; 読めた。\n修正後ファイルはこちら\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97  --- header: - type: text height: 200 paddingX: 50 paddingY: 0 align: center title: - tweet blog// subtitle: - ツイート感覚で書く技術ブログ titleColor: # #123456, red titleShadow: false titleFontSize: 44 subtitleColor: # #123456, red subtitleCursive: true subtitleFontSize: 16 spaceBetweenTitleSubtitle: 20 - type: img imageSrc: images/header/background.jpg # your image file path: root/static/images/header/background.jpg imageSize: cover # auto|length|cover|contain|initial|inherit imageRepeat: no-repeat # repeat|repeat-x|repeat-y|no-repeat|initial|inherit imagePosition: center # x% y%| xpos ypos| left top| center bottom| ... height: 235 paddingX: 50 paddingY: 0 align: center title: - tweet blog// subtitle: - ツイート感覚で書く技術ブログ titleColor: titleShadow: false titleFontSize: 44 subtitleColor: subtitleCursive: false subtitleFontSize: 16 spaceBetweenTitleSubtitle: 20 - type: slide height: 235 options: startSlide: 0 auto: 5000 # auto slide delay 5000ms(5sec) draggable: true # slide draggable autoRestart: true # restart after drag finished continuous: true # last to first disableScroll: true stopPropagation: true slide: - paddingX: 50 paddingY: 0 align: left imageSrc: images/header/background.jpg imageSize: cover imageRepeat: no-repeat imagePosition: center title: - header title1 subtitle: - header subtitle1 titleFontSize: 44 subtitleFontSize: 16 spaceBetweenTitleSubtitle: 20 - paddingX: 50 paddingY: 0 align: center imageSrc: images/header/background.jpg imageSize: cover imageRepeat: no-repeat imagePosition: center title: - header title2 subtitle: - header subtitle2 titleFontSize: 44 subtitleFontSize: 16 spaceBetweenTitleSubtitle: 20 - paddingX: 50 paddingY: 0 align: right imageSrc: images/header/background.jpg imageSize: cover imageRepeat: no-repeat imagePosition: center title: - header title3 subtitle: - header subtitle3 titleFontSize: 44 subtitleFontSize: 16 spaceBetweenTitleSubtitle: 20 ---   ビルド再挑戦！ お、きた！\nヘッダーってそっちか！\n微修正して、ビルド＆デプロイ！\nはい、昼活おわり\n","description":"","id":42,"section":"posts","tags":["hugo"],"title":"hugo/zzoのカスタムヘッダーを設定","uri":"https://encr.jp/blog/posts/20200214_lunch/"},{"content":"adsenceやろうかと思ったんだけど、先にツイートブログのルール決めたくて考えたww\nツイートブログとは？ ツイート感覚で、適当に書くブログの事\n1記事3000文字。\nとか\n写真たくさん入れる。\nとか\n読者に読みやすく。\nとか\n導線が…。\nとか考えないで書くブログ\nTwitterでの作業報告の代わりに書くブログ\nこのルールを守ると、ツイート数/2が記事数になるはず！！\nツイートブログのルール タイミング   ブログ\n 朝昼晩    ツイート\n 朝昼晩ブログの前後    内容 作業前ツイート  前回作業の記事のリンクを貼って、今回の作業の予定を書く  作業後ツイート  今回記事のリンクを貼って、やり残したこと、次回やりたい事を書く  ブログ  やった事を書く やりたかった事が出来なくてもいい。やりきれなくてもいい  ルール  作業をしたら、必ず1記事あげる 作業をしながら書いていく 進まなかったら、なんで進まなかったのかを書く  何かを試していて時間がかかった 何かを調べていて時間がかかった   タイミングは3回あるけど、毎回やる必要はない。1日1回は必ずする。  こんな感じw\nまだ3日目だけど、フォロワーさん100人くらい増えたw\nお昼も頑張るー！\n","description":"","id":43,"section":"posts","tags":["twitter"],"title":"ツイートブログの決まり","uri":"https://encr.jp/blog/posts/20200214_morning/"},{"content":"zzoのヘッダーを変える いまはこんな感じ\nなぜかタイトルがzzo…\nタイトルとロゴくらいは変えないとねww\nHugo Themes customizing\n custom header\nYou may want to change home page header. There are 4 options which is slider, image, text, empty.\nSet param at config/_default/params.toml(homeHeaderType)\nMake _index.md file at root/content/_index.md and copy \u0026amp; paste below.\n params.tomlの設定と、content/_index.mdの追加をしていきます。\nparams.tomlの設定 ん？\n4つから選択？\ntextになってるから、そのままでいいのかな？\n# header homeHeaderType = \u0026quot;text\u0026quot; # text, img, slide content/_index.mdの追加？ --- header: - type: text height: 200 paddingX: 50 paddingY: 0 align: center title: - HUGO subtitle: - The world’s fastest framework for building websites titleColor: # #123456, red titleShadow: false titleFontSize: 44 subtitleColor: # #123456, red subtitleCursive: false subtitleFontSize: 16 spaceBetweenTitleSubtitle: 20 --- 直したけど…\n全く変わらずwww\nparams.tomlを色々変えてみる とりあえず、タイトルを直したいので、色々見てみる。\nこの辺かな？\n1 2 3 4  logoText = \u0026#34;Tweet Blog\u0026#34; # Logo text that appears in the site navigation bar. logoType = \u0026#34;short\u0026#34; # long, short -\u0026gt; short: squre shape includes logo text, long: rectangle shape not includes logo text logo = false #true # Logo that appears in the site navigation bar. description = \u0026#34;つぶやく感じで適当に書く技術ブログ\u0026#34; # for SEO   あと、この辺も。プロフィールも直したい！\n1 2 3 4 5 6 7 8 9  # whoami: usage - home page sidebar, single page bottom of post. all values can be empty myname = \u0026#34;るな\u0026#34; email = \u0026#34;blog@encr.jp\u0026#34; whoami = \u0026#34;エンジニア\u0026#34; bioImageUrl = \u0026#34;images/yui.jpg\u0026#34; # image url like \u0026#34;http//...\u0026#34; or \u0026#34;images/anyfoldername/mybioimage.jpg\u0026#34; If not set, we find a avatar image in root/static/images/whoami/avatar.(png|jpg|svg) useGravatar = false # we use this option highest priority location = \u0026#34;東京\u0026#34; organization = \u0026#34;エンジョイクリエイト\u0026#34; link = \u0026#34;https://encr.jp\u0026#34;   画像はstaticにimagesフォルダを作って、そこに設置。\nあと、おまけで、defaultのカラー変えた。\n1  themeOptions = [\u0026#34;dark\u0026#34;, \u0026#34;light\u0026#34;, \u0026#34;hacker\u0026#34;, \u0026#34;solarized\u0026#34;, \u0026#34;kimbie\u0026#34;] # select options for site color theme   を\n1  themeOptions = [\u0026#34;solarized\u0026#34;, \u0026#34;light\u0026#34;, \u0026#34;hacker\u0026#34;, \u0026#34;dark\u0026#34;, \u0026#34;kimbie\u0026#34;] # select options for site color theme   にかえた。defaultは一個目みたい。\n結果 変わった！\n明日はadsenseの設置頑張りたいなーー\n","description":"","id":44,"section":"posts","tags":["hugo"],"title":"hugo/zzoのタイトルとプロフィールを変更","uri":"https://encr.jp/blog/posts/20200213_night/"},{"content":"とりあえずzzo動くようになったけど、プロフィールとかもテンプレのままなので、修正する\nfavicon設定 まず、favicon変える。\nせっかく作ってもらったからね！使いたい♡\nHugo Themes favicon\n言われた通りに設定していく。\n朝は気づかなかったけど、こんなに分かりやすい公式ページがあったみたいww\n If you want to support mobile favicon, use favicon-generator.\nMake favicons from favicon-generator site.\nMake a folder at root/static/favicon\nUnzip the generated favicon to that folder.\nSet the config param useFaviconGenerator to true\n favicon自体は別で既に作ってあるんだけど…。\nとりあえず言うとおりにする。\nfavicon作る 広告たくさんで、ダウンロードボタンが分かりずらいけど、ここ。\nfavicon設置 フォルダ作って、そこにいれる\ncd static mkdir favicon わお、いっぱいできてるww\nこれは、ちゃんとここで作らないとだめだwww\nfavicon設定 で、設定。\nuseFaviconGeneratorをtrueにしろと。\n1 2 3 4 5 6 7  ～略 description = \u0026#34;The Zzo theme for Hugo example site.\u0026#34; # for SEO custom_css = [] # custom_css = [\u0026#34;scss/custom.scss\u0026#34;] and then make file at root/assets/scss/custom.scss custom_js = [] # custom_js = [\u0026#34;js/custom.js\u0026#34;] and then make file at root/assets/js/custom.js useFaviconGenerator = true languagedir = \u0026#34;ltr\u0026#34; # ltr / rtl ～略   できた。\nあれ、怒られたwタイプミスwwww\n$ hugo server -D ERROR 2020/02/13 12:40:00 svType != tvType; key=hascjklanguage, st=bool, tt=string, sv=true, tv=true Error: \u0026quot;/mnt/c/github/runau/hugo/tweetBlog/config/_default/params.toml:7:1\u0026quot;: unmarshal failed: Near line 7 (last key parsed 'useFaviconGenerator'): expected value but found \u0026quot;ture\u0026quot; instead もっかいw\n起動！\nできた！\nでも、ほんとにfaviconだけかい！\nヘッダーは変わらないのね…\nヘッダー設定 ロゴも変えたいし、タイトルも変えたい。\n1  title = \u0026#34;つぶやく感じで適当に書く技術ブログ\u0026#34;   タイトル設定してるのに、なぜかzzo…\nなんでや…\nこれか？\nカスタムヘッダーか？\nHugo Themes customizing\n custom header\nYou may want to change home page header. There are 4 options which is slider, image, text, empty.\nSet param at config/_default/params.toml(homeHeaderType)\nMake _index.md file at root/content/_index.md and copy \u0026amp; paste below.\n params.tomlの設定と、content/_index.mdの追加な\n夜にやろう…\n","description":"","id":45,"section":"posts","tags":["hugo"],"title":"hugo/zzoに独自のfaviconを設定","uri":"https://encr.jp/blog/posts/20200213_lunch/"},{"content":"ワードプレスもそうだけど、色々テンプレデザインが落ちてるのはいいよねww\nanankeいいんだけど、もう少しおしゃれにしたいから、可愛いのに変えていく！\nブログっぽくて、多少のカスタマイズが効きそうなものを探すことにした。\nここから好きなデザインを探す！ hugo公式サイトのデザイン集\nzzo この、ザ、ブログって感じのを選択！\nhugo-theme-zzo\n設定方法 とりあえず、何も考えずにthemesの中にclone\ncd themes git clone https://github.com/zzossig/hugo-theme-zzo.git エラー続出…。 むぅ…。\nBuilding sites … ERROR 2020/02/13 07:48:06 render of \u0026quot;home\u0026quot; failed: \u0026quot;/mnt/c/github/runau/hugo/tweetBlog/themes/hugo-theme-zzo/layouts/_default/baseof.html:17:33\u0026quot;: execute of template failed: template: index.html:17:33: executing \u0026quot;index.html\u0026quot; at \u0026lt;index .Site.Params.themeOptions 0\u0026gt;: error calling index: index of untyped nil ERROR 2020/02/13 07:48:06 render of \u0026quot;page\u0026quot; failed: \u0026quot;/mnt/c/github/runau/hugo/tweetBlog/themes/hugo-theme-zzo/layouts/_default/baseof.html:17:33\u0026quot;: execute of template failed: template: _default/single.html:17:33: executing \u0026quot;_default/single.html\u0026quot; at \u0026lt;index .Site.Params.themeOptions 0\u0026gt;: error calling index: index of untyped nil ERROR 2020/02/13 07:48:06 render of \u0026quot;page\u0026quot; failed: \u0026quot;/mnt/c/github/runau/hugo/tweetBlog/themes/hugo-theme-zzo/layouts/_default/baseof.html:17:33\u0026quot;: execute of template failed: template: _default/single.html:17:33: executing \u0026quot;_default/single.html\u0026quot; at \u0026lt;index .Site.Params.themeOptions 0\u0026gt;: error calling index: index of untyped nil ERROR 2020/02/13 07:48:06 render of \u0026quot;page\u0026quot; failed: \u0026quot;/mnt/c/github/runau/hugo/tweetBlog/themes/hugo-theme-zzo/layouts/_default/baseof.html:17:33\u0026quot;: execute of template failed: template: _default/single.html:17:33: executing \u0026quot;_default/single.html\u0026quot; at \u0026lt;index .Site.Params.themeOptions 0\u0026gt;: error calling index: index of untyped nil Built in 11327 ms Error: Error building site: failed to render pages: render of \u0026quot;section\u0026quot; failed: \u0026quot;/mnt/c/github/runau/hugo/tweetBlog/themes/hugo-theme-zzo/layouts/_default/baseof.html:17:33\u0026quot;: execute of template failed: template: _default/list.html:17:33: executing \u0026quot;_default/list.html\u0026quot; at \u0026lt;index .Site.Params.themeOptions 0\u0026gt;: error calling index: index of untyped nil うーん、とりあえず、サブモジュールにしてみる？ git submodule add https://github.com/zzossig/hugo-theme-zzo.git themes/zzo でも変わらず…。\nなんか、カスタマイズが必要系のテーマはconfig的な設定をしないと動かないよう。\nconfigファイルを作る https://zzodocs.netlify.com/docs/configuration/configfiles/\nこの辺の設定してみる。\n動いたみたい。\n$ hugo server -D ERROR 2020/02/13 08:34:46 svType != tvType; key=hascjklanguage, st=bool, tt=string, sv=true, tv=true | EN | KO -------------------+----+----- Pages | 26 | 13 Paginator pages | 0 | 0 Non-page files | 1 | 0 Static files | 70 | 70 Processed images | 0 | 0 Aliases | 3 | 1 Sitemaps | 2 | 1 Cleaned | 0 | 0 Built in 9647 ms Watching for changes in /mnt/c/github/runau/hugo/tweetBlog/{archetypes,content,data,layouts,static,themes} Watching for config changes in /mnt/c/github/runau/hugo/tweetBlog/config.toml, /mnt/c/github/runau/hugo/tweetBlog/config/_default Environment: \u0026quot;development\u0026quot; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop ちょっと色々設定変えなきゃいけなそうだけど、それはまたお昼に\nとりあえず、前のバックアップも上げっぱなし\nanankeバージョン\n","description":"","id":46,"section":"posts","tags":["hugo"],"title":"hugoのテーマをzzoに変えてみる","uri":"https://encr.jp/blog/posts/20200213_morning/"},{"content":"バイトメンター.com 今度linebotのハンズオン勉強会しようかな。と思って、何作ろうかなーと思ってたら、これ作りたくなった！\n頑張って作るぞー！\nバイトメンター.comとは？ アプリから誰でも簡単にお助けメンターを呼び出せるという、画期的なサービスですww\n元ネタはこちらww\n龍が如く7　バイトヒーロー.com　始動\nシステム構成 画像埋め込むの大変だったから、今日はここまで…w\n埋め込み方法は、ここを参考にしました。\nhttps://hugo.nakaken88.com/use/image/\n","description":"","id":47,"section":"posts","tags":["aws"],"title":"バイトメンター.com","uri":"https://encr.jp/blog/posts/20200212_night/"},{"content":"hugo初期設定との戦い ミスドランチをしながら、30分で頑張る！\n記事出てこない問題 hugo new posts/20200212_morning.md して、記事ページは作られてるんだけど、\nhugo server -D すると、ちゃんと記事出てくるんだけど、\nhugo -t ananke デプロイすると、記事がない…\ndraft: true 記事ページのヘッダーにこいつがいたせいだった。\n下書きって意味らしく、これが付いていると、デプロイされないらしい！便利！\ncssとか反映されない問題 なんとかデプロイしたけど、cssとか、全く効いてない。\nなんならリンクも効いてない。\nデプロイ後のソース覗くと、リンク先がこんなのになってる…\nhttp://hugo.example.com/posts/xxxxx\n1  baseURL = \u0026#34;https://encr.jp/blog\u0026#34;   個々の設定しないといけないみたい。\n無事cssもきれいに表示\nついでにタイトルとかも変える！ 1 2 3 4 5  baseURL = \u0026#34;https://encr.jp/blog\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;つぶやく感じで適当に書く技術ブログ\u0026#34; theme = \u0026#34;ananke\u0026#34; hasCJKLanguage = \u0026#34;true\u0026#34;   SEOのために、トップページへのリンク張る フッダーあたりがいいなー\nと思ったけど、これ、カスタマイズ扱いになってしまうのね…。\n本腰入れてやらないと無理かね？\nやりたいことリストに入れておこ\nとりあえず、google先生にクロールだけでもしてほしいから、リンク貼っておこww\nエンクリ\n","description":"","id":48,"section":"posts","tags":["hugo"],"title":"hugo初期設定と戦ってみる","uri":"https://encr.jp/blog/posts/20200212_lunch/"},{"content":"ブログ作った Twitterで今日の積み上げとかやるけど、残らないし、twitterだと細かいこと書けないし、ブログにした\nやった事とか、困ったこととか、ツイート感覚で書いていこうと思う！\nhugoって？ ブログを静的に作れるすごい奴\nしかも、記事をマークダウンで書ける！\n作り方 https://dev.classmethod.jp/cloud/hugo-s3/\nこれをそのままやった\n一部こっちも見ている。\nhttps://dev.classmethod.jp/etc/hugo-super-fast-static-webpage/\nテーマはhugo-unoは上手く動かなかったから、こっちのananke使ってみた\ns3からcloudfrontでroute53で独自ドメインで表示してる。\nこの辺を詳しく書こうとすると、記事アップのハードル上がるから、今回は書かないw\nさ、お風呂入って、会社行こ\n","description":"","id":49,"section":"posts","tags":["hugo"],"title":"hugoでつぶやきブログ作った","uri":"https://encr.jp/blog/posts/20200212_morning/"}]